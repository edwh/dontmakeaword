{"version":3,"sources":["webpack:///./node_modules/bootstrap-vue/src/components/tooltip/helpers/bv-tooltip.js","webpack:///./node_modules/bootstrap-vue/src/directives/visible/visible.js","webpack:///./node_modules/bootstrap-vue/src/components/popover/helpers/bv-popover-template.js","webpack:///./node_modules/bootstrap-vue/src/components/popover/helpers/bv-popover.js","webpack:///./node_modules/bootstrap-vue/src/components/tooltip/helpers/bv-popper.js","webpack:///./node_modules/bootstrap-vue/src/components/tooltip/helpers/bv-tooltip-template.js","webpack:///./node_modules/bootstrap-vue/src/components/toast/toast.js","webpack:///./node_modules/bootstrap-vue/src/directives/modal/modal.js","webpack:///./node_modules/bootstrap-vue/src/components/tooltip/tooltip.js","webpack:///./node_modules/bootstrap-vue/src/components/toast/toaster.js","webpack:///./node_modules/bootstrap-vue/src/directives/popover/popover.js","webpack:///./node_modules/bootstrap-vue/src/directives/popover/index.js","webpack:///./node_modules/bootstrap-vue/src/components/toast/helpers/bv-toast.js","webpack:///./node_modules/bootstrap-vue/src/components/progress/progress-bar.js","webpack:///./node_modules/bootstrap-vue/src/components/progress/progress.js","webpack:///./node_modules/bootstrap-vue/src/components/progress/index.js","webpack:///./node_modules/bootstrap-vue/src/components/tabs/tabs.js","webpack:///./node_modules/bootstrap-vue/src/components/tabs/tab.js","webpack:///./node_modules/bootstrap-vue/src/components/tabs/index.js","webpack:///./node_modules/bootstrap-vue/src/directives/scrollspy/scrollspy.class.js","webpack:///./node_modules/bootstrap-vue/src/directives/scrollspy/scrollspy.js","webpack:///./node_modules/bootstrap-vue/src/directives/scrollspy/index.js","webpack:///./node_modules/bootstrap-vue/src/components/popover/popover.js","webpack:///./node_modules/bootstrap-vue/src/components/popover/index.js","webpack:///./node_modules/bootstrap-vue/src/directives/tooltip/tooltip.js","webpack:///./node_modules/bootstrap-vue/src/directives/tooltip/index.js","webpack:///./node_modules/bootstrap-vue/src/directives/toggle/toggle.js"],"names":["templateData","title","content","variant","customClass","triggers","placement","fallbackPlacement","target","container","noFade","boundary","boundaryPadding","offset","delay","arrowPadding","interactive","disabled","id","html","BVTooltip","Vue","extend","name","props","data","activeTrigger","hover","click","focus","localShow","computed","templateType","computedId","this","_uid","computedDelay","show","hide","isPlainObject","Math","max","parseInt","isNumber","isString","computedTriggers","concat","filter","Boolean","join","trim","toLowerCase","split","sort","isWithActiveTrigger","trigger","computedTemplateData","watch","newTriggers","oldTriggers","looseEqual","$nextTick","unListen","forEach","arrayIncludes","listen","handleTemplateUpdate","newVal","disable","enable","created","$_tip","$_hoverTimeout","$_hoverState","$_visibleInterval","$_enabled","$_noop","noop","bind","$parent","$once","$destroy","getTarget","contains","document","body","scopeId","getScopId","warn","updated","deactivated","forceHide","beforeDestroy","setWhileOpenListeners","clearHoverTimeout","clearVisibilityInterval","destroyTemplate","methods","getTemplate","BVTooltipTemplate","updateData","titleUpdated","keys","prop","isUndefined","fixTitle","createTemplateAndShow","getContainer","Template","$tip","parent","propsData","getPlacementTarget","getBoundary","onTemplateShow","onTemplateShown","onTemplateHide","onTemplateHidden","$on","handleEvent","$mount","appendChild","createElement","hideTemplate","clearActiveTriggers","localPlacementTarget","removeAriaDescribedby","restoreTitle","getTemplateElement","$el","isVisible","dropdownOpen","isUndefinedOrNull","showEvt","buildEvent","cancelable","emitEvent","defaultPrevented","addAriaDescribedby","force","tip","hideEvt","prevHoverState","leave","getById","replace","isFunction","isElement","getTargetId","closest","isInModal","isDropdown","hasClass","select","clearTimeout","clearInterval","desc","getAttr","setAttr","d","removeAttr","hasAttr","type","options","BvEvent","relatedTarget","componentId","vueTarget","bvEvt","evtName","$root","$emit","el","setRootListener","eventOn","EVENT_OPTIONS_NO_CAPTURE","evt","eventOff","on","method","doHide","doShow","doDisable","doEnable","setModalListener","setDropdownListener","visibleCheck","setOnTouchStartListener","setInterval","parentNode","documentElement","arrayFrom","children","eventOnOff","__vue__","isDisabled","enter","evtTarget","toggle","setTimeout","OBSERVER_PROP_NAME","onlyDgitsRE","VisibilityObserver","vnode","callback","margin","once","observer","visible","undefined","doneOnce","createObserver","stop","IntersectionObserver","handler","root","rootMargin","threshold","context","requestAF","observe","entries","entry","isIntersecting","intersectionRatio","disconnect","destroy","value","modifiers","mod","test","_prevModifiers","clone","VBVisible","componentUpdated","oldValue","unbind","BVPopoverTemplate","extends","renderTemplate","h","$title","$content","titleDomProps","innerHTML","contentDomProps","staticClass","class","templateClasses","attrs","templateAttributes","templateListeners","ref","domProps","BVPopover","AttachmentMap","AUTO","TOP","RIGHT","BOTTOM","LEFT","TOPLEFT","TOPRIGHT","RIGHTTOP","RIGHTBOTTOM","BOTTOMLEFT","BOTTOMRIGHT","LEFTTOP","LEFTBOTTOM","OffsetMap","BVPopper","HTMLElement","SVGElement","default","String","Array","Number","attachment","getAttachment","popperConfig","getOffset","flip","behavior","arrow","element","preventOverflow","padding","boundariesElement","onCreate","originalPlacement","popperPlacementChange","onUpdate","$_popper","popperCreate","beforeMount","mounted","popperUpdate","popperDestroy","destroyed","removeChild","toUpperCase","$refs","arrowOffset","parseFloat","getCS","width","Popper","scheduleUpdate","render","BVTransition","appear","beforeEnter","afterEnter","beforeLeave","afterLeave","mixins","scopedStyleAttrsMixin","noninteractive","role","tabindex","scopedStyleAttrs","mouseenter","mouseleave","focusin","focusout","NAME","toaster","getComponentConfig","isStatus","appendToast","noAutoHide","autoHideDelay","noCloseButton","noHoverPause","solid","toastClass","Object","headerClass","bodyClass","href","to","static","BToast","idMixin","listenOnRootMixin","normalizeSlotMixin","inheritAttrs","model","event","isMounted","doRender","isTransitioning","isHiding","order","timer","dismissStarted","resumeDismiss","bToastClasses","slotScope","computedDuration","toInteger","computedToaster","transitionHandlers","onBeforeEnter","onAfterEnter","onBeforeLeave","onAfterLeave","ensureToaster","listenOnRoot","safeId","clearDismissTimer","Date","now","setHoverHandler","Wormhole","hasTarget","div","BToaster","startDismissTimer","onPause","onUnPause","passed","onLinkClick","hiddenEvt","makeToast","$headerContent","normalizeSlot","push","BButtonClose","$header","length","isLink","$body","BLink","key","$attrs","Portal","slim","PROPERTY","arg","reverse","getTriggerElement","matches","setRole","tagName","oldProp","EVENT_OPTIONS_PASSIVE","binding","currentTarget","keyCode","KeyCodes","ENTER","SPACE","VBModal","inserted","BTooltip","Function","required","validator","isArray","every","v","localTitle","localContent","templateTitleContent","oldVal","$_bv_toolpop","updateContent","$off","doOpen","doClose","Component","getComponent","$toolpop","_scopeId","onShow","onShown","onHide","onHidden","onDisabled","onEnabled","setTitle","$scopedSlots","val","setContent","ariaLive","ariaAtomic","DefaultTransition","removeClass","tag","$slots","dead","staticName","$toaster","$target","PortalTarget","multiple","transition","BV_POPOVER","validTriggers","blur","manual","htmlRE","noFadeRE","placementRE","boundaryRE","delayRE","delayShowRE","delayHideRE","offsetRE","variantRE","spacesRE","parseBindings","bindings","config","animation","slice","selectedTriggers","identity","applyPopover","isBrowser","__bv_prev_data__","oldData","newData","VBPopover","removePopover","VBPopoverPlugin","pluginFactory","directives","BASE_PROPS","omit","toastProps","propsToSlots","toastContent","filterOptions","reduce","memo","BVToastPlugin","plugins","plugin","BToastPop","self","handleDestroy","warnNotClient","toast","$createElement","BvToast","vm","assign","_vm","_root","defineProperties","readonlyDescriptor","mixin","beforeCreate","prototype","hasOwnProperty","defineProperty","get","BProgressBar","inject","bvProgress","label","labelHtml","precision","striped","animated","showProgress","showValue","progressBarClasses","computedVariant","computedStriped","computedAnimated","progressBarStyles","computedValue","computedMax","toFloat","isNaN","computedPrecision","computedProgress","p","pow","toFixed","isBoolean","computedShowProgress","computedShowValue","childNodes","hasNormalizedSlot","htmlOrText","style","toString","BProgress","provide","height","progressHeight","ProgressPlugin","components","navProps","BNavProps","notDisabled","tab","BTabButtonHelper","bvTabs","tabs","controls","tabIndex","posInSet","setSize","noKeyNav","link","handleEvt","preventDefault","stopPropagation","shift","shiftKey","UP","HOME","DOWN","END","active","localActive","titleLinkClass","activeNavItemClass","titleLinkAttributes","keydown","titleItemClass","BTabs","card","end","noNavStyle","lazy","contentClass","navClass","navWrapperClass","activeTabClass","tabIdx","currentTab","registeredTabs","fade","localNavClass","classes","vertical","index","idx","activateTab","previousTab","nextTab","updateTabs","map","t","setObserver","_bvObserver","activated","registerTab","unregisterTab","observeDom","tabsContainer","childList","subtree","attributes","attributeFilter","getTabs","$children","_isTab","selector","selectAll","stableSort","a","b","indexOf","find","getButtonForTab","buttons","btn","updateButton","button","$forceUpdate","result","tabEvt","deactivateTab","focusButton","emitTabClick","isEvent","clickTab","firstTab","currentIndex","lastTab","activeTab","fallbackTab","refInFor","controlledBy","first","prev","next","last","nav","BNav","fill","justified","align","pills","small","cardHeader","empty","col","row","BTab","buttonId","noBody","tabClasses","computedNoFade","computedLazy","activate","deactivate","rawName","expression","mode","TabsPlugin","Default","throttle","DefaultType","ClassName","Selector","ACTIVE","NAV_LIST_GROUP","NAV_LINKS","NAV_ITEMS","LIST_ITEMS","DROPDOWN","DROPDOWN_ITEMS","DROPDOWN_TOGGLE","OffsetMethod","HREF_REGEX","TransitionEndEvents","ScrollSpy","$scroller","$selector","$offsets","$targets","$activeTarget","$scrollHeight","$resizeTimeout","$obs_scroller","$obs_targets","$config","updateConfig","unlisten","cfg","constructor","componentName","configTypes","property","call","expectedTypes","valueType","obj","objectToString","match","_isVue","RegExp","typeCheckConfig","Name","scroller","getScroller","window","setObservers","characterData","process","refresh","autoMethod","methodFn","position","offsetBase","getScrollTop","getScrollHeight","top","item","scrollTop","scrollHeight","maxScroll","getOffsetHeight","clear","i","pageYOffset","innerHeight","getBCR","links","dropdown","setActiveState","parentElement","sibling","previousElementSibling","addClass","BV_SCROLLSPY","onlyDigitsRE","applyScrollspy","round","isObject","k","VBScrollspy","update","dispose","removeScrollspy","VBScrollspyPlugin","BPopover","PopoverPlugin","BV_TOOLTIP","noninteractiveRE","applyTooltip","VBTooltip","removeTooltip","VBTooltipPlugin","listenTypes","BV_TOGGLE","EVENT_TOGGLE","EVENT_STATE","EVENT_STATE_SYNC","EVENT_STATE_REQUEST","resetProp","handleTargets","targets","handleUpdate","getTargets","unbindTargets","bindTargets","VBToggle","state"],"mappings":"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","file":"7fd3200532c0d272a219.js","sourcesContent":["// Tooltip \"Class\" (Built as a renderless Vue instance)\n//\n// Handles trigger events, etc.\n// Instantiates template on demand\n\nimport Vue from '../../../utils/vue'\nimport getScopId from '../../../utils/get-scope-id'\nimport looseEqual from '../../../utils/loose-equal'\nimport noop from '../../../utils/noop'\nimport { arrayIncludes, concat, from as arrayFrom } from '../../../utils/array'\nimport {\n  closest,\n  contains,\n  getAttr,\n  getById,\n  hasAttr,\n  hasClass,\n  isDisabled,\n  isElement,\n  isVisible,\n  removeAttr,\n  select,\n  setAttr\n} from '../../../utils/dom'\nimport { EVENT_OPTIONS_NO_CAPTURE, eventOn, eventOff, eventOnOff } from '../../../utils/events'\nimport {\n  isFunction,\n  isNumber,\n  isPlainObject,\n  isString,\n  isUndefined,\n  isUndefinedOrNull\n} from '../../../utils/inspect'\nimport { keys } from '../../../utils/object'\nimport { warn } from '../../../utils/warn'\nimport { BvEvent } from '../../../utils/bv-event.class'\nimport { BVTooltipTemplate } from './bv-tooltip-template'\n\nconst NAME = 'BVTooltip'\n\n// Modal container selector for appending tooltip/popover\nconst MODAL_SELECTOR = '.modal-content'\n// Modal `$root` hidden event\nconst MODAL_CLOSE_EVENT = 'bv::modal::hidden'\n\n// For dropdown sniffing\nconst DROPDOWN_CLASS = 'dropdown'\nconst DROPDOWN_OPEN_SELECTOR = '.dropdown-menu.show'\n\n// Data specific to popper and template\n// We don't use props, as we need reactivity (we can't pass reactive props)\nconst templateData = {\n  // Text string or Scoped slot function\n  title: '',\n  // Text string or Scoped slot function\n  content: '',\n  // String\n  variant: null,\n  // String, Array, Object\n  customClass: null,\n  // String or array of Strings (overwritten by BVPopper)\n  triggers: '',\n  // String (overwritten by BVPopper)\n  placement: 'auto',\n  // String or array of strings\n  fallbackPlacement: 'flip',\n  // Element or Component reference (or function that returns element) of\n  // the element that will have the trigger events bound, and is also\n  // default element for positioning\n  target: null,\n  // HTML ID, Element or Component reference\n  container: null, // 'body'\n  // Boolean\n  noFade: false,\n  // 'scrollParent', 'viewport', 'window', Element, or Component reference\n  boundary: 'scrollParent',\n  // Tooltip/popover will try and stay away from\n  // boundary edge by this many pixels (Number)\n  boundaryPadding: 5,\n  // Arrow offset (Number)\n  offset: 0,\n  // Hover/focus delay (Number or Object)\n  delay: 0,\n  // Arrow of Tooltip/popover will try and stay away from\n  // the edge of tooltip/popover edge by this many pixels\n  arrowPadding: 6,\n  // Interactive state (Boolean)\n  interactive: true,\n  // Disabled state (Boolean)\n  disabled: false,\n  // ID to use for tooltip/popover\n  id: null,\n  // Flag used by directives only, for HTML content\n  html: false\n}\n\n// @vue/component\nexport const BVTooltip = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  props: {\n    // None\n  },\n  data() {\n    return {\n      // BTooltip/BPopover/VBTooltip/VBPopover will update this data\n      // Via the exposed updateData() method on this instance\n      // BVPopover will override some of these defaults\n      ...templateData,\n      // State management data\n      activeTrigger: {\n        // manual: false,\n        hover: false,\n        click: false,\n        focus: false\n      },\n      localShow: false\n    }\n  },\n  computed: {\n    templateType() {\n      // Overwritten by BVPopover\n      return 'tooltip'\n    },\n    computedId() {\n      return this.id || `__bv_${this.templateType}_${this._uid}__`\n    },\n    computedDelay() {\n      // Normalizes delay into object form\n      const delay = { show: 0, hide: 0 }\n      if (isPlainObject(this.delay)) {\n        delay.show = Math.max(parseInt(this.delay.show, 10) || 0, 0)\n        delay.hide = Math.max(parseInt(this.delay.hide, 10) || 0, 0)\n      } else if (isNumber(this.delay) || isString(this.delay)) {\n        delay.show = delay.hide = Math.max(parseInt(this.delay, 10) || 0, 0)\n      }\n      return delay\n    },\n    computedTriggers() {\n      // Returns the triggers in sorted array form\n      // TODO: Switch this to object form for easier lookup\n      return concat(this.triggers)\n        .filter(Boolean)\n        .join(' ')\n        .trim()\n        .toLowerCase()\n        .split(/\\s+/)\n        .sort()\n    },\n    isWithActiveTrigger() {\n      for (const trigger in this.activeTrigger) {\n        if (this.activeTrigger[trigger]) {\n          return true\n        }\n      }\n      return false\n    },\n    computedTemplateData() {\n      return {\n        title: this.title,\n        content: this.content,\n        variant: this.variant,\n        customClass: this.customClass,\n        noFade: this.noFade,\n        interactive: this.interactive\n      }\n    }\n  },\n  watch: {\n    computedTriggers(newTriggers, oldTriggers) {\n      // Triggers have changed, so re-register them\n      /* istanbul ignore next */\n      if (!looseEqual(newTriggers, oldTriggers)) {\n        this.$nextTick(() => {\n          // Disable trigger listeners\n          this.unListen()\n          // Clear any active triggers that are no longer in the list of triggers\n          oldTriggers.forEach(trigger => {\n            if (!arrayIncludes(newTriggers, trigger)) {\n              if (this.activeTrigger[trigger]) {\n                this.activeTrigger[trigger] = false\n              }\n            }\n          })\n          // Re-enable the trigger listeners\n          this.listen()\n        })\n      }\n    },\n    computedTemplateData() {\n      // If any of the while open reactive \"props\" change,\n      // ensure that the template updates accordingly\n      this.handleTemplateUpdate()\n    },\n    disabled(newVal) {\n      newVal ? this.disable() : this.enable()\n    }\n  },\n  created() {\n    // Create non-reactive properties\n    this.$_tip = null\n    this.$_hoverTimeout = null\n    this.$_hoverState = ''\n    this.$_visibleInterval = null\n    this.$_enabled = !this.disabled\n    this.$_noop = noop.bind(this)\n\n    // Destroy ourselves when the parent is destroyed\n    if (this.$parent) {\n      this.$parent.$once('hook:beforeDestroy', this.$destroy)\n    }\n\n    this.$nextTick(() => {\n      const target = this.getTarget()\n      if (target && contains(document.body, target)) {\n        // Copy the parent's scoped style attribute\n        this.scopeId = getScopId(this.$parent)\n        // Set up all trigger handlers and listeners\n        this.listen()\n      } else {\n        /* istanbul ignore next */\n        warn('Unable to find target element in document.', this.templateType)\n      }\n    })\n  },\n  updated() /* istanbul ignore next */ {\n    // Usually called when the slots/data changes\n    this.$nextTick(this.handleTemplateUpdate)\n  },\n  deactivated() /* istanbul ignore next */ {\n    // In a keepalive that has been deactivated, so hide\n    // the tooltip/popover if it is showing\n    this.forceHide()\n  },\n  beforeDestroy() /* istanbul ignore next */ {\n    // Remove all handler/listeners\n    this.unListen()\n    this.setWhileOpenListeners(false)\n    // Clear any timeouts/intervals\n    this.clearHoverTimeout()\n    this.clearVisibilityInterval()\n    // Destroy the template\n    this.destroyTemplate()\n  },\n  methods: {\n    // --- Methods for creating and destroying the template ---\n    getTemplate() {\n      // Overridden by BVPopover\n      return BVTooltipTemplate\n    },\n    updateData(data = {}) {\n      // Method for updating popper/template data\n      // We only update data if it exists, and has not changed\n      let titleUpdated = false\n      keys(templateData).forEach(prop => {\n        if (!isUndefined(data[prop]) && this[prop] !== data[prop]) {\n          this[prop] = data[prop]\n          if (prop === 'title') {\n            titleUpdated = true\n          }\n        }\n      })\n      if (titleUpdated && this.localShow) {\n        // If the title has updated, we may need to handle the title\n        // attribute on the trigger target. We only do this while the\n        // template is open\n        this.fixTitle()\n      }\n    },\n    createTemplateAndShow() {\n      // Creates the template instance and show it\n      const container = this.getContainer()\n      const Template = this.getTemplate()\n      const $tip = (this.$_tip = new Template({\n        parent: this,\n        // The following is not reactive to changes in the props data\n        propsData: {\n          // These values cannot be changed while template is showing\n          id: this.computedId,\n          html: this.html,\n          placement: this.placement,\n          fallbackPlacement: this.fallbackPlacement,\n          target: this.getPlacementTarget(),\n          boundary: this.getBoundary(),\n          // Ensure the following are integers\n          offset: parseInt(this.offset, 10) || 0,\n          arrowPadding: parseInt(this.arrowPadding, 10) || 0,\n          boundaryPadding: parseInt(this.boundaryPadding, 10) || 0\n        }\n      }))\n      // We set the initial reactive data (values that can be changed while open)\n      this.handleTemplateUpdate()\n      // Template transition phase events (handled once only)\n      // When the template has mounted, but not visibly shown yet\n      $tip.$once('show', this.onTemplateShow)\n      // When the template has completed showing\n      $tip.$once('shown', this.onTemplateShown)\n      // When the template has started to hide\n      $tip.$once('hide', this.onTemplateHide)\n      // When the template has completed hiding\n      $tip.$once('hidden', this.onTemplateHidden)\n      // When the template gets destroyed for any reason\n      $tip.$once('hook:destroyed', this.destroyTemplate)\n      // Convenience events from template\n      // To save us from manually adding/removing DOM\n      // listeners to tip element when it is open\n      $tip.$on('focusin', this.handleEvent)\n      $tip.$on('focusout', this.handleEvent)\n      $tip.$on('mouseenter', this.handleEvent)\n      $tip.$on('mouseleave', this.handleEvent)\n      // Mount (which triggers the `show`)\n      $tip.$mount(container.appendChild(document.createElement('div')))\n      // Template will automatically remove its markup from DOM when hidden\n    },\n    hideTemplate() {\n      // Trigger the template to start hiding\n      // The template will emit the `hide` event after this and\n      // then emit the `hidden` event once it is fully hidden\n      // The `hook:destroyed` will also be called (safety measure)\n      this.$_tip && this.$_tip.hide()\n      // Clear out any stragging active triggers\n      this.clearActiveTriggers()\n      // Reset the hover state\n      this.$_hoverState = ''\n    },\n    // Destroy the template instance and reset state\n    destroyTemplate() {\n      this.setWhileOpenListeners(false)\n      this.clearHoverTimeout()\n      this.$_hoverState = ''\n      this.clearActiveTriggers()\n      this.localPlacementTarget = null\n      try {\n        this.$_tip && this.$_tip.$destroy()\n      } catch {}\n      this.$_tip = null\n      this.removeAriaDescribedby()\n      this.restoreTitle()\n      this.localShow = false\n    },\n    getTemplateElement() {\n      return this.$_tip ? this.$_tip.$el : null\n    },\n    handleTemplateUpdate() {\n      // Update our template title/content \"props\"\n      // So that the template updates accordingly\n      const $tip = this.$_tip\n      if ($tip) {\n        const props = ['title', 'content', 'variant', 'customClass', 'noFade', 'interactive']\n        // Only update the values if they have changed\n        props.forEach(prop => {\n          if ($tip[prop] !== this[prop]) {\n            $tip[prop] = this[prop]\n          }\n        })\n      }\n    },\n    // --- Show/Hide handlers ---\n    // Show the tooltip\n    show() {\n      const target = this.getTarget()\n      if (\n        !target ||\n        !contains(document.body, target) ||\n        !isVisible(target) ||\n        this.dropdownOpen() ||\n        ((isUndefinedOrNull(this.title) || this.title === '') &&\n          (isUndefinedOrNull(this.content) || this.content === ''))\n      ) {\n        // If trigger element isn't in the DOM or is not visible, or\n        // is on an open dropdown toggle, or has no content, then\n        // we exit without showing\n        return\n      }\n      // If tip already exists, exit early\n      if (this.$_tip || this.localShow) {\n        /* istanbul ignore next */\n        return\n      }\n      // In the process of showing\n      this.localShow = true\n      // Create a cancelable BvEvent\n      const showEvt = this.buildEvent('show', { cancelable: true })\n      this.emitEvent(showEvt)\n      // Don't show if event cancelled\n      /* istanbul ignore next: ignore for now */\n      if (showEvt.defaultPrevented) {\n        // Destroy the template (if for some reason it was created)\n        /* istanbul ignore next */\n        this.destroyTemplate()\n        /* istanbul ignore next */\n        return\n      }\n      // Fix the title attribute on target\n      this.fixTitle()\n      // Set aria-describedby on target\n      this.addAriaDescribedby()\n      // Create and show the tooltip\n      this.createTemplateAndShow()\n    },\n    hide(force = false) {\n      // Hide the tooltip\n      const tip = this.getTemplateElement()\n      if (!tip || !this.localShow) {\n        /* istanbul ignore next */\n        this.restoreTitle()\n        /* istanbul ignore next */\n        return\n      }\n\n      // Emit cancelable BvEvent 'hide'\n      // We disable cancelling if `force` is true\n      const hideEvt = this.buildEvent('hide', { cancelable: !force })\n      this.emitEvent(hideEvt)\n      /* istanbul ignore next: ignore for now */\n      if (hideEvt.defaultPrevented) {\n        // Don't hide if event cancelled\n        /* istanbul ignore next */\n        return\n      }\n\n      // Tell the template to hide\n      this.hideTemplate()\n    },\n    forceHide() {\n      // Forcefully hides/destroys the template, regardless of any active triggers\n      const tip = this.getTemplateElement()\n      if (!tip || !this.localShow) {\n        /* istanbul ignore next */\n        return\n      }\n      // Disable while open listeners/watchers\n      // This is also done in the template `hide` evt handler\n      this.setWhileOpenListeners(false)\n      // Clear any hover enter/leave event\n      this.clearHoverTimeout()\n      this.$_hoverState = ''\n      this.clearActiveTriggers()\n      // Disable the fade animation on the template\n      if (this.$_tip) {\n        this.$_tip.noFade = true\n      }\n      // Hide the tip (with force = true)\n      this.hide(true)\n    },\n    enable() {\n      this.$_enabled = true\n      // Create a non-cancelable BvEvent\n      this.emitEvent(this.buildEvent('enabled'))\n    },\n    disable() {\n      this.$_enabled = false\n      // Create a non-cancelable BvEvent\n      this.emitEvent(this.buildEvent('disabled'))\n    },\n    // --- Handlers for template events ---\n    // When template is inserted into DOM, but not yet shown\n    onTemplateShow() {\n      // Enable while open listeners/watchers\n      this.setWhileOpenListeners(true)\n    },\n    // When template show transition completes\n    onTemplateShown() {\n      const prevHoverState = this.$_hoverState\n      this.$_hoverState = ''\n      if (prevHoverState === 'out') {\n        this.leave(null)\n      }\n      // Emit a non-cancelable BvEvent 'shown'\n      this.emitEvent(this.buildEvent('shown'))\n    },\n    // When template is starting to hide\n    onTemplateHide() {\n      // Disable while open listeners/watchers\n      this.setWhileOpenListeners(false)\n    },\n    // When template has completed closing (just before it self destructs)\n    onTemplateHidden() {\n      // Destroy the template\n      this.destroyTemplate()\n      // Emit a non-cancelable BvEvent 'shown'\n      this.emitEvent(this.buildEvent('hidden'))\n    },\n    // --- Utility methods ---\n    getTarget() {\n      // Handle case where target may be a component ref\n      let target = this.target ? this.target.$el || this.target : null\n      // If an ID\n      target = isString(target) ? getById(target.replace(/^#/, '')) : target\n      // If a function\n      target = isFunction(target) ? target() : target\n      // If an element ref\n      return isElement(target) ? target : null\n    },\n    getPlacementTarget() {\n      // This is the target that the tooltip will be placed on, which may not\n      // necessarily be the same element that has the trigger event listeners\n      // For now, this is the same as target\n      // TODO:\n      //   Add in child selector support\n      //   Add in visibility checks for this element\n      //   Fallback to target if not found\n      return this.getTarget()\n    },\n    getTargetId() {\n      // Returns the ID of the trigger element\n      const target = this.getTarget()\n      return target && target.id ? target.id : null\n    },\n    getContainer() {\n      // Handle case where container may be a component ref\n      const container = this.container ? this.container.$el || this.container : false\n      const body = document.body\n      const target = this.getTarget()\n      // If we are in a modal, we append to the modal instead\n      // of body, unless a container is specified\n      // TODO:\n      //   Template should periodically check to see if it is in dom\n      //   And if not, self destruct (if container got v-if'ed out of DOM)\n      //   Or this could possibly be part of the visibility check\n      return container === false\n        ? closest(MODAL_SELECTOR, target) || body\n        : isString(container)\n          ? getById(container.replace(/^#/, '')) || body\n          : body\n    },\n    getBoundary() {\n      return this.boundary ? this.boundary.$el || this.boundary : 'scrollParent'\n    },\n    isInModal() {\n      const target = this.getTarget()\n      return target && closest(MODAL_SELECTOR, target)\n    },\n    isDropdown() {\n      // Returns true if trigger is a dropdown\n      const target = this.getTarget()\n      return target && hasClass(target, DROPDOWN_CLASS)\n    },\n    dropdownOpen() {\n      // Returns true if trigger is a dropdown and the dropdown menu is open\n      const target = this.getTarget()\n      return this.isDropdown() && target && select(DROPDOWN_OPEN_SELECTOR, target)\n    },\n    clearHoverTimeout() {\n      if (this.$_hoverTimeout) {\n        clearTimeout(this.$_hoverTimeout)\n        this.$_hoverTimeout = null\n      }\n    },\n    clearVisibilityInterval() {\n      if (this.$_visibleInterval) {\n        clearInterval(this.$_visibleInterval)\n        this.$_visibleInterval = null\n      }\n    },\n    clearActiveTriggers() {\n      for (const trigger in this.activeTrigger) {\n        this.activeTrigger[trigger] = false\n      }\n    },\n    addAriaDescribedby() {\n      // Add aria-describedby on trigger element, without removing any other IDs\n      const target = this.getTarget()\n      let desc = getAttr(target, 'aria-describedby') || ''\n      desc = desc\n        .split(/\\s+/)\n        .concat(this.computedId)\n        .join(' ')\n        .trim()\n      // Update/add aria-described by\n      setAttr(target, 'aria-describedby', desc)\n    },\n    removeAriaDescribedby() {\n      // Remove aria-describedby on trigger element, without removing any other IDs\n      const target = this.getTarget()\n      let desc = getAttr(target, 'aria-describedby') || ''\n      desc = desc\n        .split(/\\s+/)\n        .filter(d => d !== this.computedId)\n        .join(' ')\n        .trim()\n      // Update or remove aria-describedby\n      if (desc) {\n        /* istanbul ignore next */\n        setAttr(target, 'aria-describedby', desc)\n      } else {\n        removeAttr(target, 'aria-describedby')\n      }\n    },\n    fixTitle() {\n      // If the target has a title attribute, null it out and\n      // store on data-title\n      const target = this.getTarget()\n      if (target && getAttr(target, 'title')) {\n        // We only update title attribute if it has a value\n        setAttr(target, 'data-original-title', getAttr(target, 'title') || '')\n        setAttr(target, 'title', '')\n      }\n    },\n    restoreTitle() {\n      // If target had a title, restore the title attribute\n      // and remove the data-title attribute\n      const target = this.getTarget()\n      if (target && hasAttr(target, 'data-original-title')) {\n        setAttr(target, 'title', getAttr(target, 'data-original-title') || '')\n        removeAttr(target, 'data-original-title')\n      }\n    },\n    // --- BvEvent helpers ---\n    buildEvent(type, options = {}) {\n      // Defaults to a non-cancellable event\n      return new BvEvent(type, {\n        cancelable: false,\n        target: this.getTarget(),\n        relatedTarget: this.getTemplateElement() || null,\n        componentId: this.computedId,\n        vueTarget: this,\n        // Add in option overrides\n        ...options\n      })\n    },\n    emitEvent(bvEvt) {\n      // Emits a BvEvent on $root and this instance\n      const evtName = bvEvt.type\n      const $root = this.$root\n      if ($root && $root.$emit) {\n        // Emit an event on $root\n        $root.$emit(`bv::${this.templateType}::${evtName}`, bvEvt)\n      }\n      this.$emit(evtName, bvEvt)\n    },\n    // --- Event handler setup methods ---\n    listen() {\n      // Enable trigger event handlers\n      const el = this.getTarget()\n      if (!el) {\n        /* istanbul ignore next */\n        return\n      }\n      // Listen for global show/hide events\n      this.setRootListener(true)\n      // Set up our listeners on the target trigger element\n      this.computedTriggers.forEach(trigger => {\n        if (trigger === 'click') {\n          eventOn(el, 'click', this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n        } else if (trigger === 'focus') {\n          eventOn(el, 'focusin', this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n          eventOn(el, 'focusout', this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n        } else if (trigger === 'blur') {\n          // Used to close $tip when element looses focus\n          /* istanbul ignore next */\n          eventOn(el, 'focusout', this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n        } else if (trigger === 'hover') {\n          eventOn(el, 'mouseenter', this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n          eventOn(el, 'mouseleave', this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n        }\n      }, this)\n    },\n    unListen() /* istanbul ignore next */ {\n      // Remove trigger event handlers\n      const events = ['click', 'focusin', 'focusout', 'mouseenter', 'mouseleave']\n      const target = this.getTarget()\n\n      // Stop listening for global show/hide/enable/disable events\n      this.setRootListener(false)\n\n      // Clear out any active target listeners\n      events.forEach(evt => {\n        target && eventOff(target, evt, this.handleEvent, EVENT_OPTIONS_NO_CAPTURE)\n      }, this)\n    },\n    setRootListener(on) {\n      // Listen for global `bv::{hide|show}::{tooltip|popover}` hide request event\n      const $root = this.$root\n      if ($root) {\n        const method = on ? '$on' : '$off'\n        const type = this.templateType\n        $root[method](`bv::hide::${type}`, this.doHide)\n        $root[method](`bv::show::${type}`, this.doShow)\n        $root[method](`bv::disable::${type}`, this.doDisable)\n        $root[method](`bv::enable::${type}`, this.doEnable)\n      }\n    },\n    setWhileOpenListeners(on) {\n      // Events that are only registered when the template is showing\n      // Modal close events\n      this.setModalListener(on)\n      // Dropdown open events (if we are attached to a dropdown)\n      this.setDropdownListener(on)\n      // Periodic $element visibility check\n      // For handling when tip target is in <keepalive>, tabs, carousel, etc\n      this.visibleCheck(on)\n      // On-touch start listeners\n      this.setOnTouchStartListener(on)\n    },\n    // Handler for periodic visibility check\n    visibleCheck(on) {\n      this.clearVisibilityInterval()\n      const target = this.getTarget()\n      const tip = this.getTemplateElement()\n      if (on) {\n        this.$_visibleInterval = setInterval(() => {\n          if (tip && this.localShow && (!target.parentNode || !isVisible(target))) {\n            // Target element is no longer visible or not in DOM, so force-hide the tooltip\n            this.forceHide()\n          }\n        }, 100)\n      }\n    },\n    setModalListener(on) {\n      // Handle case where tooltip/target is in a modal\n      if (this.isInModal()) {\n        // We can listen for modal hidden events on `$root`\n        this.$root[on ? '$on' : '$off'](MODAL_CLOSE_EVENT, this.forceHide)\n      }\n    },\n    setOnTouchStartListener(on) /* istanbul ignore next: JSDOM doesn't support `ontouchstart` */ {\n      // If this is a touch-enabled device we add extra empty\n      // `mouseover` listeners to the body's immediate children\n      // Only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n      if ('ontouchstart' in document.documentElement) {\n        arrayFrom(document.body.children).forEach(el => {\n          eventOnOff(on, el, 'mouseover', this.$_noop)\n        })\n      }\n    },\n    setDropdownListener(on) {\n      const target = this.getTarget()\n      if (!target || !this.$root || !this.isDropdown) {\n        return\n      }\n      // We can listen for dropdown shown events on its instance\n      // TODO:\n      //   We could grab the ID from the dropdown, and listen for\n      //   $root events for that particular dropdown id\n      //   Dropdown shown and hidden events will need to emit\n      //   Note: Dropdown auto-ID happens in a `$nextTick()` after mount\n      //         So the ID lookup would need to be done in a `$nextTick()`\n      if (target.__vue__) {\n        target.__vue__[on ? '$on' : '$off']('shown', this.forceHide)\n      }\n    },\n    // --- Event handlers ---\n    handleEvent(evt) {\n      // General trigger event handler\n      // target is the trigger element\n      const target = this.getTarget()\n      if (!target || isDisabled(target) || !this.$_enabled || this.dropdownOpen()) {\n        // If disabled or not enabled, or if a dropdown that is open, don't do anything\n        // If tip is shown before element gets disabled, then tip will not\n        // close until no longer disabled or forcefully closed\n        return\n      }\n      const type = evt.type\n      const triggers = this.computedTriggers\n\n      if (type === 'click' && arrayIncludes(triggers, 'click')) {\n        this.click(evt)\n      } else if (type === 'mouseenter' && arrayIncludes(triggers, 'hover')) {\n        // `mouseenter` is a non-bubbling event\n        this.enter(evt)\n      } else if (type === 'focusin' && arrayIncludes(triggers, 'focus')) {\n        // `focusin` is a bubbling event\n        // `evt` includes `relatedTarget` (element loosing focus)\n        this.enter(evt)\n      } else if (\n        (type === 'focusout' &&\n          (arrayIncludes(triggers, 'focus') || arrayIncludes(triggers, 'blur'))) ||\n        (type === 'mouseleave' && arrayIncludes(triggers, 'hover'))\n      ) {\n        // `focusout` is a bubbling event\n        // `mouseleave` is a non-bubbling event\n        // `tip` is the template (will be null if not open)\n        const tip = this.getTemplateElement()\n        // `evtTarget` is the element which is loosing focus/hover and\n        const evtTarget = evt.target\n        // `relatedTarget` is the element gaining focus/hover\n        const relatedTarget = evt.relatedTarget\n        /* istanbul ignore next */\n        if (\n          // From tip to target\n          (tip && contains(tip, evtTarget) && contains(target, relatedTarget)) ||\n          // From target to tip\n          (tip && contains(target, evtTarget) && contains(tip, relatedTarget)) ||\n          // Within tip\n          (tip && contains(tip, evtTarget) && contains(tip, relatedTarget)) ||\n          // Within target\n          (contains(target, evtTarget) && contains(target, relatedTarget))\n        ) {\n          // If focus/hover moves within `tip` and `target`, don't trigger a leave\n          return\n        }\n        // Otherwise trigger a leave\n        this.leave(evt)\n      }\n    },\n    doHide(id) {\n      // Programmatically hide tooltip or popover\n      if (!id || (this.getTargetId() === id || this.computedId === id)) {\n        // Close all tooltips or popovers, or this specific tip (with ID)\n        this.forceHide()\n      }\n    },\n    doShow(id) {\n      // Programmatically show tooltip or popover\n      if (!id || (this.getTargetId() === id || this.computedId === id)) {\n        // Open all tooltips or popovers, or this specific tip (with ID)\n        this.show()\n      }\n    },\n    doDisable(id) /*istanbul ignore next: ignore for now */ {\n      // Programmatically disable tooltip or popover\n      if (!id || (this.getTargetId() === id || this.computedId === id)) {\n        // Disable all tooltips or popovers (no ID), or this specific tip (with ID)\n        this.disable()\n      }\n    },\n    doEnable(id) /*istanbul ignore next: ignore for now */ {\n      // Programmatically enable tooltip or popover\n      if (!id || (this.getTargetId() === id || this.computedId === id)) {\n        // Enable all tooltips or popovers (no ID), or this specific tip (with ID)\n        this.enable()\n      }\n    },\n    click() {\n      if (!this.$_enabled || this.dropdownOpen()) {\n        /* istanbul ignore next */\n        return\n      }\n      this.activeTrigger.click = !this.activeTrigger.click\n      if (this.isWithActiveTrigger) {\n        this.enter(null)\n      } else {\n        /* istanbul ignore next */\n        this.leave(null)\n      }\n    },\n    toggle() /* istanbul ignore next */ {\n      // Manual toggle handler\n      if (!this.$_enabled || this.dropdownOpen()) {\n        /* istanbul ignore next */\n        return\n      }\n      // Should we register as an active trigger?\n      // this.activeTrigger.manual = !this.activeTrigger.manual\n      if (this.localShow) {\n        this.leave(null)\n      } else {\n        this.enter(null)\n      }\n    },\n    enter(evt = null) {\n      // Opening trigger handler\n      // Note: Click events are sent with evt === null\n      if (evt) {\n        this.activeTrigger[evt.type === 'focusin' ? 'focus' : 'hover'] = true\n      }\n      /* istanbul ignore next */\n      if (this.localShow || this.$_hoverState === 'in') {\n        this.$_hoverState = 'in'\n        return\n      }\n      this.clearHoverTimeout()\n      this.$_hoverState = 'in'\n      if (!this.computedDelay.show) {\n        this.show()\n      } else {\n        // Hide any title attribute while enter delay is active\n        this.fixTitle()\n        this.$_hoverTimeout = setTimeout(() => {\n          /* istanbul ignore else */\n          if (this.$_hoverState === 'in') {\n            this.show()\n          } else if (!this.localShow) {\n            this.restoreTitle()\n          }\n        }, this.computedDelay.show)\n      }\n    },\n    leave(evt = null) {\n      // Closing trigger handler\n      // Note: Click events are sent with evt === null\n      if (evt) {\n        this.activeTrigger[evt.type === 'focusout' ? 'focus' : 'hover'] = false\n        /* istanbul ignore next */\n        if (evt.type === 'focusout' && arrayIncludes(this.computedTriggers, 'blur')) {\n          // Special case for `blur`: we clear out the other triggers\n          this.activeTrigger.click = false\n          this.activeTrigger.hover = false\n        }\n      }\n      /* istanbul ignore next: ignore for now */\n      if (this.isWithActiveTrigger) {\n        return\n      }\n      this.clearHoverTimeout()\n      this.$_hoverState = 'out'\n      if (!this.computedDelay.hide) {\n        this.hide()\n      } else {\n        this.$_hoverTimeout = setTimeout(() => {\n          if (this.$_hoverState === 'out') {\n            this.hide()\n          }\n        }, this.computedDelay.hide)\n      }\n    }\n  }\n})\n","// v-b-visible\n// Private visibility check directive\n// Based on IntersectionObserver\n//\n// Usage:\n//  v-b-visibility.<margin>.<once>=\"<callback>\"\n//\n//  Value:\n//  <callback>: method to be called when visibility state changes, receives one arg:\n//     true:  element is visible\n//     false: element is not visible\n//     null:  IntersectionObserver not supported\n//\n//  Modifiers:\n//    <margin>: a positive decimal value of pixels away from viewport edge\n//              before being considered \"visible\". default is 0\n//    <once>:   keyword 'once', meaning when the element becomes visible and\n//              callback is called observation/notification will stop.\n//\n// When used in a render function:\n// export default {\n//   directives: { 'b-visible': VBVisible },\n//   render(h) {\n//     h(\n//       'div',\n//       {\n//         directives: [\n//           { name: 'b-visible', value=this.callback, modifiers: { '123':true, 'once':true } }\n//         ]\n//       }\n//     )\n//   }\n\nimport looseEqual from '../../utils/loose-equal'\nimport { requestAF } from '../../utils/dom'\nimport { isFunction } from '../../utils/inspect'\nimport { clone, keys } from '../../utils/object'\n\nconst OBSERVER_PROP_NAME = '__bv__visibility_observer'\n\nconst onlyDgitsRE = /^\\d+$/\n\nclass VisibilityObserver {\n  constructor(el, options, vnode) {\n    this.el = el\n    this.callback = options.callback\n    this.margin = options.margin || 0\n    this.once = options.once || false\n    this.observer = null\n    this.visible = undefined\n    this.doneOnce = false\n    // Create the observer instance (if possible)\n    this.createObserver(vnode)\n  }\n\n  createObserver(vnode) {\n    // Remove any previous observer\n    if (this.observer) {\n      /* istanbul ignore next */\n      this.stop()\n    }\n\n    // Should only be called once and `callback` prop should be a function\n    if (this.doneOnce || !isFunction(this.callback)) {\n      /* istanbul ignore next */\n      return\n    }\n\n    // Create the observer instance\n    try {\n      // Future: Possibly add in other modifiers for left/right/top/bottom\n      // offsets, root element reference, and thresholds\n      this.observer = new IntersectionObserver(this.handler.bind(this), {\n        // `null` = 'viewport'\n        root: null,\n        // Pixels away from view port to consider \"visible\"\n        rootMargin: this.margin,\n        // Intersection ratio of el and root (as a value from 0 to 1)\n        threshold: 0\n      })\n    } catch {\n      // No IntersectionObserver support, so just stop trying to observe\n      this.doneOnce = true\n      this.observer = undefined\n      this.callback(null)\n      return\n    }\n\n    // Start observing in a `$nextTick()` (to allow DOM to complete rendering)\n    /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n    vnode.context.$nextTick(() => {\n      requestAF(() => {\n        // Placed in an `if` just in case we were destroyed before\n        // this `requestAnimationFrame` runs\n        if (this.observer) {\n          this.observer.observe(this.el)\n        }\n      })\n    })\n  }\n\n  handler(entries) /* istanbul ignore next: IntersectionObserver not supported in JSDOM */ {\n    const entry = entries ? entries[0] : {}\n    const isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0)\n    if (isIntersecting !== this.visible) {\n      this.visible = isIntersecting\n      this.callback(isIntersecting)\n      if (this.once && this.visible) {\n        this.doneOnce = true\n        this.stop()\n      }\n    }\n  }\n\n  stop() {\n    const observer = this.observer\n    /* istanbul ignore next */\n    if (observer && observer.disconnect) {\n      observer.disconnect()\n    }\n    this.observer = null\n  }\n}\n\nconst destroy = el => {\n  const observer = el[OBSERVER_PROP_NAME]\n  if (observer && observer.stop) {\n    observer.stop()\n  }\n  delete el[OBSERVER_PROP_NAME]\n}\n\nconst bind = (el, { value, modifiers }, vnode) => {\n  // `value` is the callback function\n  const options = {\n    margin: '0px',\n    once: false,\n    callback: value\n  }\n  // Parse modifiers\n  keys(modifiers).forEach(mod => {\n    /* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */\n    if (onlyDgitsRE.test(mod)) {\n      options.margin = `${mod}px`\n    } else if (mod.toLowerCase() === 'once') {\n      options.once = true\n    }\n  })\n  // Destroy any previous observer\n  destroy(el)\n  // Create new observer\n  el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options, vnode)\n  // Store the current modifiers on the object (cloned)\n  el[OBSERVER_PROP_NAME]._prevModifiers = clone(modifiers)\n}\n\n// When the directive options may have been updated (or element)\nconst componentUpdated = (el, { value, oldValue, modifiers }, vnode) => {\n  // Compare value/oldValue and modifiers to see if anything has changed\n  // and if so, destroy old observer and create new observer\n  /* istanbul ignore next */\n  modifiers = clone(modifiers)\n  /* istanbul ignore next */\n  if (\n    el &&\n    (value !== oldValue ||\n      !el[OBSERVER_PROP_NAME] ||\n      !looseEqual(modifiers, el[OBSERVER_PROP_NAME]._prevModifiers))\n  ) {\n    // Re-bind on element\n    bind(el, { value, modifiers }, vnode)\n  }\n}\n\n// When directive un-binds from element\nconst unbind = el => {\n  // Remove the observer\n  destroy(el)\n}\n\n// Export the directive\nexport const VBVisible = {\n  bind,\n  componentUpdated,\n  unbind\n}\n","import Vue from '../../../utils/vue'\nimport { isFunction, isUndefinedOrNull } from '../../../utils/inspect'\n\nimport { BVTooltipTemplate } from '../../tooltip/helpers/bv-tooltip-template'\n\nconst NAME = 'BVPopoverTemplate'\n\n// @vue/component\nexport const BVPopoverTemplate = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  extends: BVTooltipTemplate,\n  computed: {\n    templateType() {\n      return 'popover'\n    }\n  },\n  methods: {\n    renderTemplate(h) {\n      // Title and content could be a scoped slot function\n      const $title = isFunction(this.title) ? this.title({}) : this.title\n      const $content = isFunction(this.content) ? this.content({}) : this.content\n\n      // Directive usage only\n      const titleDomProps = this.html && !isFunction(this.title) ? { innerHTML: this.title } : {}\n      const contentDomProps =\n        this.html && !isFunction(this.content) ? { innerHTML: this.content } : {}\n\n      return h(\n        'div',\n        {\n          staticClass: 'popover b-popover',\n          class: this.templateClasses,\n          attrs: this.templateAttributes,\n          on: this.templateListeners\n        },\n        [\n          h('div', { ref: 'arrow', staticClass: 'arrow' }),\n          isUndefinedOrNull($title) || $title === ''\n            ? h()\n            : h('h3', { staticClass: 'popover-header', domProps: titleDomProps }, [$title]),\n          isUndefinedOrNull($content) || $content === ''\n            ? h()\n            : h('div', { staticClass: 'popover-body', domProps: contentDomProps }, [$content])\n        ]\n      )\n    }\n  }\n})\n","// Popover \"Class\" (Built as a renderless Vue instance)\n// Inherits from BVTooltip\n//\n// Handles trigger events, etc.\n// Instantiates template on demand\n\nimport Vue from '../../../utils/vue'\nimport { BVTooltip } from '../../tooltip/helpers/bv-tooltip'\nimport { BVPopoverTemplate } from './bv-popover-template'\n\nconst NAME = 'BVPopover'\n\n// @vue/component\nexport const BVPopover = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  extends: BVTooltip,\n  computed: {\n    // Overwrites BVTooltip\n    templateType() {\n      return 'popover'\n    }\n  },\n  methods: {\n    getTemplate() {\n      // Overwrites BVTooltip\n      return BVPopoverTemplate\n    }\n  }\n})\n","// Base on-demand component for tooltip / popover templates\n//\n// Currently:\n//   Responsible for positioning and transitioning the template\n//   Templates are only instantiated when shown, and destroyed when hidden\n//\n\nimport Vue from '../../../utils/vue'\nimport Popper from 'popper.js'\nimport { getCS, select } from '../../../utils/dom'\nimport { HTMLElement, SVGElement } from '../../../utils/safe-types'\nimport { BVTransition } from '../../../utils/bv-transition'\n\nconst NAME = 'BVPopper'\n\nconst AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left',\n  TOPLEFT: 'top',\n  TOPRIGHT: 'top',\n  RIGHTTOP: 'right',\n  RIGHTBOTTOM: 'right',\n  BOTTOMLEFT: 'bottom',\n  BOTTOMRIGHT: 'bottom',\n  LEFTTOP: 'left',\n  LEFTBOTTOM: 'left'\n}\n\nconst OffsetMap = {\n  AUTO: 0,\n  TOPLEFT: -1,\n  TOP: 0,\n  TOPRIGHT: +1,\n  RIGHTTOP: -1,\n  RIGHT: 0,\n  RIGHTBOTTOM: +1,\n  BOTTOMLEFT: -1,\n  BOTTOM: 0,\n  BOTTOMRIGHT: +1,\n  LEFTTOP: -1,\n  LEFT: 0,\n  LEFTBOTTOM: +1\n}\n\n// @vue/component\nexport const BVPopper = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  props: {\n    target: {\n      // Element that the tooltip/popover is positioned relative to\n      type: [HTMLElement, SVGElement],\n      default: null\n    },\n    placement: {\n      type: String,\n      default: 'top'\n    },\n    fallbackPlacement: {\n      type: [String, Array],\n      default: 'flip'\n    },\n    offset: {\n      type: Number,\n      default: 0\n    },\n    boundary: {\n      // 'scrollParent', 'viewport', 'window', or Element\n      type: [String, HTMLElement],\n      default: 'scrollParent'\n    },\n    boundaryPadding: {\n      // Tooltip/popover will try and stay away from\n      // boundary edge by this many pixels\n      type: Number,\n      default: 5\n    },\n    arrowPadding: {\n      // The minimum distance (in `px`) from the edge of the\n      // tooltip/popover that the arrow can be positioned\n      type: Number,\n      default: 6\n    }\n  },\n  data() {\n    return {\n      // reactive props set by parent\n      noFade: false,\n      // State related data\n      localShow: true,\n      attachment: this.getAttachment(this.placement)\n    }\n  },\n  computed: {\n    templateType() /* istanbul ignore next */ {\n      // Overridden by template component\n      return 'unknown'\n    },\n    popperConfig() {\n      const placement = this.placement\n      return {\n        placement: this.getAttachment(placement),\n        modifiers: {\n          offset: { offset: this.getOffset(placement) },\n          flip: { behavior: this.fallbackPlacement },\n          // `arrow.element` can also be a reference to an HTML Element\n          // maybe we should make this a `$ref` in the templates?\n          arrow: { element: '.arrow' },\n          preventOverflow: {\n            padding: this.boundaryPadding,\n            boundariesElement: this.boundary\n          }\n        },\n        onCreate: data => {\n          // Handle flipping arrow classes\n          if (data.originalPlacement !== data.placement) {\n            /* istanbul ignore next: can't test in JSDOM */\n            this.popperPlacementChange(data)\n          }\n        },\n        onUpdate: data => {\n          // Handle flipping arrow classes\n          this.popperPlacementChange(data)\n        }\n      }\n    }\n  },\n  created() {\n    // Note: We are created on-demand, and should be guaranteed that\n    // DOM is rendered/ready by the time the created hook runs\n    this.$_popper = null\n    // Ensure we show as we mount\n    this.localShow = true\n    // Create popper instance before shown\n    this.$on('show', el => {\n      this.popperCreate(el)\n    })\n    // Self destruct once hidden\n    this.$on('hidden', () => {\n      this.$nextTick(this.$destroy)\n    })\n    // If parent is destroyed, ensure we are destroyed\n    this.$parent.$once('hook:destroyed', this.$destroy)\n  },\n  beforeMount() {\n    // Ensure that the attachment position is correct before mounting\n    // as our propsData is added after `new Template({...})`\n    this.attachment = this.getAttachment(this.placement)\n  },\n  mounted() {\n    // TBD\n  },\n  updated() {\n    // Update popper if needed\n    // TODO: Should this be a watcher on `this.popperConfig` instead?\n    this.popperUpdate()\n  },\n  beforeDestroy() {\n    this.popperDestroy()\n  },\n  destroyed() {\n    // Make sure template is removed from DOM\n    const el = this.$el\n    el && el.parentNode && el.parentNode.removeChild(el)\n  },\n  methods: {\n    // \"Public\" method to trigger hide template\n    hide() {\n      this.localShow = false\n    },\n    // Private\n    getAttachment(placement) {\n      return AttachmentMap[String(placement).toUpperCase()] || 'auto'\n    },\n    getOffset(placement) {\n      if (!this.offset) {\n        // Could set a ref for the arrow element\n        const arrow = this.$refs.arrow || select('.arrow', this.$el)\n        const arrowOffset =\n          (parseFloat(getCS(arrow).width) || 0) + (parseFloat(this.arrowPadding) || 0)\n        switch (OffsetMap[String(placement).toUpperCase()] || 0) {\n          case +1:\n            /* istanbul ignore next: can't test in JSDOM */\n            return `+50%p - ${arrowOffset}px`\n          case -1:\n            /* istanbul ignore next: can't test in JSDOM */\n            return `-50%p + ${arrowOffset}px`\n          default:\n            return 0\n        }\n      }\n      /* istanbul ignore next */\n      return this.offset\n    },\n    popperCreate(el) {\n      this.popperDestroy()\n      // We use `el` rather than `this.$el` just in case the original\n      // mountpoint root element type was changed by the template\n      this.$_popper = new Popper(this.target, el, this.popperConfig)\n    },\n    popperDestroy() {\n      this.$_popper && this.$_popper.destroy()\n      this.$_popper = null\n    },\n    popperUpdate() {\n      this.$_popper && this.$_popper.scheduleUpdate()\n    },\n    popperPlacementChange(data) {\n      // Callback used by popper to adjust the arrow placement\n      this.attachment = this.getAttachment(data.placement)\n    },\n    renderTemplate(h) /* istanbul ignore next */ {\n      // Will be overridden by templates\n      return h('div')\n    }\n  },\n  render(h) {\n    // Note: `show` and 'fade' classes are only appled during transition\n    return h(\n      BVTransition,\n      {\n        // Transitions as soon as mounted\n        props: { appear: true, noFade: this.noFade },\n        on: {\n          // Events used by parent component/instance\n          beforeEnter: el => this.$emit('show', el),\n          afterEnter: el => this.$emit('shown', el),\n          beforeLeave: el => this.$emit('hide', el),\n          afterLeave: el => this.$emit('hidden', el)\n        }\n      },\n      [this.localShow ? this.renderTemplate(h) : h()]\n    )\n  }\n})\n","import Vue from '../../../utils/vue'\nimport scopedStyleAttrsMixin from '../../../mixins/scoped-style-attrs'\nimport { isFunction, isUndefinedOrNull } from '../../../utils/inspect'\nimport { BVPopper } from './bv-popper'\n\nconst NAME = 'BVTooltipTemplate'\n\n// @vue/component\nexport const BVTooltipTemplate = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  extends: BVPopper,\n  mixins: [scopedStyleAttrsMixin],\n  props: {\n    // Other non-reactive (while open) props are pulled in from BVPopper\n    id: {\n      type: String,\n      default: null\n    },\n    html: {\n      // Used only by the directive versions\n      type: Boolean,\n      default: false\n    }\n  },\n  data() {\n    // We use data, rather than props to ensure reactivity\n    // Parent component will directly set this data\n    return {\n      title: '',\n      content: '',\n      variant: null,\n      customClass: null,\n      interactive: true\n    }\n  },\n  computed: {\n    templateType() {\n      return 'tooltip'\n    },\n    templateClasses() {\n      return [\n        {\n          // Disables pointer events to hide the tooltip when the user\n          // hovers over its content\n          noninteractive: !this.interactive,\n          [`b-${this.templateType}-${this.variant}`]: this.variant,\n          // `attachment` will come from BVToolpop\n          [`bs-${this.templateType}-${this.attachment}`]: this.attachment\n        },\n        this.customClass\n      ]\n    },\n    templateAttributes() {\n      return {\n        id: this.id,\n        role: 'tooltip',\n        tabindex: '-1',\n        // Add the scoped style data attribute to the template root element\n        ...this.scopedStyleAttrs\n      }\n    },\n    templateListeners() {\n      // Used for hover/focus trigger listeners\n      return {\n        mouseenter: evt => {\n          /* istanbul ignore next: difficult to test in JSDOM */\n          this.$emit('mouseenter', evt)\n        },\n        mouseleave: evt => {\n          /* istanbul ignore next: difficult to test in JSDOM */\n          this.$emit('mouseleave', evt)\n        },\n        focusin: evt => {\n          /* istanbul ignore next: difficult to test in JSDOM */\n          this.$emit('focusin', evt)\n        },\n        focusout: evt => {\n          /* istanbul ignore next: difficult to test in JSDOM */\n          this.$emit('focusout', evt)\n        }\n      }\n    }\n  },\n  methods: {\n    renderTemplate(h) {\n      // Title can be a scoped slot function\n      const $title = isFunction(this.title)\n        ? this.title({})\n        : isUndefinedOrNull(this.title)\n          ? h()\n          : this.title\n\n      // Directive versions only\n      const domProps = this.html && !isFunction(this.title) ? { innerHTML: this.title } : {}\n\n      return h(\n        'div',\n        {\n          staticClass: 'tooltip b-tooltip',\n          class: this.templateClasses,\n          attrs: this.templateAttributes,\n          on: this.templateListeners\n        },\n        [\n          h('div', { ref: 'arrow', staticClass: 'arrow' }),\n          h('div', { staticClass: 'tooltip-inner', domProps }, [$title])\n        ]\n      )\n    }\n  }\n})\n","import Vue from '../../utils/vue'\nimport { Portal, Wormhole } from 'portal-vue'\nimport BVTransition from '../../utils/bv-transition'\nimport { BvEvent } from '../../utils/bv-event.class'\nimport { getComponentConfig } from '../../utils/config'\nimport { requestAF } from '../../utils/dom'\nimport { EVENT_OPTIONS_NO_CAPTURE, eventOnOff } from '../../utils/events'\nimport { toInteger } from '../../utils/number'\nimport idMixin from '../../mixins/id'\nimport listenOnRootMixin from '../../mixins/listen-on-root'\nimport normalizeSlotMixin from '../../mixins/normalize-slot'\nimport scopedStyleAttrsMixin from '../../mixins/scoped-style-attrs'\nimport { BToaster } from './toaster'\nimport { BButtonClose } from '../button/button-close'\nimport { BLink } from '../link/link'\n\n// --- Constants ---\n\nconst NAME = 'BToast'\n\nconst MIN_DURATION = 1000\n\n// --- Props ---\n\nexport const props = {\n  id: {\n    // Even though the ID prop is provided by idMixin, we\n    // add it here for $bvToast props filtering\n    type: String,\n    default: null\n  },\n  title: {\n    type: String,\n    default: null\n  },\n  toaster: {\n    type: String,\n    default: () => getComponentConfig(NAME, 'toaster')\n  },\n  visible: {\n    type: Boolean,\n    default: false\n  },\n  variant: {\n    type: String,\n    default: () => getComponentConfig(NAME, 'variant')\n  },\n  isStatus: {\n    // Switches role to 'status' and aria-live to 'polite'\n    type: Boolean,\n    default: false\n  },\n  appendToast: {\n    type: Boolean,\n    default: false\n  },\n  noAutoHide: {\n    type: Boolean,\n    default: false\n  },\n  autoHideDelay: {\n    type: [Number, String],\n    default: () => getComponentConfig(NAME, 'autoHideDelay')\n  },\n  noCloseButton: {\n    type: Boolean,\n    default: false\n  },\n  noFade: {\n    type: Boolean,\n    default: false\n  },\n  noHoverPause: {\n    type: Boolean,\n    default: false\n  },\n  solid: {\n    type: Boolean,\n    default: false\n  },\n  toastClass: {\n    type: [String, Object, Array],\n    default: () => getComponentConfig(NAME, 'toastClass')\n  },\n  headerClass: {\n    type: [String, Object, Array],\n    default: () => getComponentConfig(NAME, 'headerClass')\n  },\n  bodyClass: {\n    type: [String, Object, Array],\n    default: () => getComponentConfig(NAME, 'bodyClass')\n  },\n  href: {\n    type: String,\n    default: null\n  },\n  to: {\n    type: [String, Object],\n    default: null\n  },\n  static: {\n    // Render the toast in place, rather than in a portal-target\n    type: Boolean,\n    default: false\n  }\n}\n\n// @vue/component\nexport const BToast = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  mixins: [idMixin, listenOnRootMixin, normalizeSlotMixin, scopedStyleAttrsMixin],\n  inheritAttrs: false,\n  model: {\n    prop: 'visible',\n    event: 'change'\n  },\n  props,\n  data() {\n    return {\n      isMounted: false,\n      doRender: false,\n      localShow: false,\n      isTransitioning: false,\n      isHiding: false,\n      order: 0,\n      timer: null,\n      dismissStarted: 0,\n      resumeDismiss: 0\n    }\n  },\n  computed: {\n    bToastClasses() {\n      return {\n        'b-toast-solid': this.solid,\n        'b-toast-append': this.appendToast,\n        'b-toast-prepend': !this.appendToast,\n        [`b-toast-${this.variant}`]: this.variant\n      }\n    },\n    slotScope() {\n      return {\n        hide: this.hide\n      }\n    },\n    computedDuration() {\n      // Minimum supported duration is 1 second\n      return Math.max(toInteger(this.autoHideDelay) || 0, MIN_DURATION)\n    },\n    computedToaster() {\n      return String(this.toaster)\n    },\n    transitionHandlers() {\n      return {\n        beforeEnter: this.onBeforeEnter,\n        afterEnter: this.onAfterEnter,\n        beforeLeave: this.onBeforeLeave,\n        afterLeave: this.onAfterLeave\n      }\n    }\n  },\n  watch: {\n    visible(newVal) {\n      newVal ? this.show() : this.hide()\n    },\n    localShow(newVal) {\n      if (newVal !== this.visible) {\n        this.$emit('change', newVal)\n      }\n    },\n    toaster() /* istanbul ignore next */ {\n      // If toaster target changed, make sure toaster exists\n      this.$nextTick(this.ensureToaster)\n    },\n    static(newVal) /* istanbul ignore next */ {\n      // If static changes to true, and the toast is showing,\n      // ensure the toaster target exists\n      if (newVal && this.localShow) {\n        this.ensureToaster()\n      }\n    }\n  },\n  mounted() {\n    this.isMounted = true\n    this.$nextTick(() => {\n      if (this.visible) {\n        requestAF(() => {\n          this.show()\n        })\n      }\n    })\n    // Listen for global $root show events\n    this.listenOnRoot('bv::show::toast', id => {\n      if (id === this.safeId()) {\n        this.show()\n      }\n    })\n    // Listen for global $root hide events\n    this.listenOnRoot('bv::hide::toast', id => {\n      if (!id || id === this.safeId()) {\n        this.hide()\n      }\n    })\n    // Make sure we hide when toaster is destroyed\n    /* istanbul ignore next: difficult to test */\n    this.listenOnRoot('bv::toaster::destroyed', toaster => {\n      /* istanbul ignore next */\n      if (toaster === this.computedToaster) {\n        /* istanbul ignore next */\n        this.hide()\n      }\n    })\n  },\n  beforeDestroy() {\n    this.clearDismissTimer()\n  },\n  methods: {\n    show() {\n      if (!this.localShow) {\n        this.ensureToaster()\n        const showEvt = this.buildEvent('show')\n        this.emitEvent(showEvt)\n        this.dismissStarted = this.resumeDismiss = 0\n        this.order = Date.now() * (this.appendToast ? 1 : -1)\n        this.isHiding = false\n        this.doRender = true\n        this.$nextTick(() => {\n          // We show the toast after we have rendered the portal and b-toast wrapper\n          // so that screen readers will properly announce the toast\n          requestAF(() => {\n            this.localShow = true\n          })\n        })\n      }\n    },\n    hide() {\n      if (this.localShow) {\n        const hideEvt = this.buildEvent('hide')\n        this.emitEvent(hideEvt)\n        this.setHoverHandler(false)\n        this.dismissStarted = this.resumeDismiss = 0\n        this.clearDismissTimer()\n        this.isHiding = true\n        requestAF(() => {\n          this.localShow = false\n        })\n      }\n    },\n    buildEvent(type, options = {}) {\n      return new BvEvent(type, {\n        cancelable: false,\n        target: this.$el || null,\n        relatedTarget: null,\n        ...options,\n        vueTarget: this,\n        componentId: this.safeId()\n      })\n    },\n    emitEvent(bvEvt) {\n      const type = bvEvt.type\n      this.$root.$emit(`bv::toast:${type}`, bvEvt)\n      this.$emit(type, bvEvt)\n    },\n    ensureToaster() {\n      if (this.static) {\n        return\n      }\n      if (!Wormhole.hasTarget(this.computedToaster)) {\n        const div = document.createElement('div')\n        document.body.appendChild(div)\n        const toaster = new BToaster({\n          parent: this.$root,\n          propsData: {\n            name: this.computedToaster\n          }\n        })\n        toaster.$mount(div)\n      }\n    },\n    startDismissTimer() {\n      this.clearDismissTimer()\n      if (!this.noAutoHide) {\n        this.timer = setTimeout(this.hide, this.resumeDismiss || this.computedDuration)\n        this.dismissStarted = Date.now()\n        this.resumeDismiss = 0\n      }\n    },\n    clearDismissTimer() {\n      clearTimeout(this.timer)\n      this.timer = null\n    },\n    setHoverHandler(on) {\n      const el = this.$refs['b-toast']\n      eventOnOff(on, el, 'mouseenter', this.onPause, EVENT_OPTIONS_NO_CAPTURE)\n      eventOnOff(on, el, 'mouseleave', this.onUnPause, EVENT_OPTIONS_NO_CAPTURE)\n    },\n    onPause() {\n      // Determine time remaining, and then pause timer\n      if (this.noAutoHide || this.noHoverPause || !this.timer || this.resumeDismiss) {\n        return\n      }\n      const passed = Date.now() - this.dismissStarted\n      if (passed > 0) {\n        this.clearDismissTimer()\n        this.resumeDismiss = Math.max(this.computedDuration - passed, MIN_DURATION)\n      }\n    },\n    onUnPause() {\n      // Restart timer with max of time remaining or 1 second\n      if (this.noAutoHide || this.noHoverPause || !this.resumeDismiss) {\n        this.resumeDismiss = this.dismissStarted = 0\n        return\n      }\n      this.startDismissTimer()\n    },\n    onLinkClick() {\n      // We delay the close to allow time for the\n      // browser to process the link click\n      this.$nextTick(() => {\n        requestAF(() => {\n          this.hide()\n        })\n      })\n    },\n    onBeforeEnter() {\n      this.isTransitioning = true\n    },\n    onAfterEnter() {\n      this.isTransitioning = false\n      const hiddenEvt = this.buildEvent('shown')\n      this.emitEvent(hiddenEvt)\n      this.startDismissTimer()\n      this.setHoverHandler(true)\n    },\n    onBeforeLeave() {\n      this.isTransitioning = true\n    },\n    onAfterLeave() {\n      this.isTransitioning = false\n      this.order = 0\n      this.resumeDismiss = this.dismissStarted = 0\n      const hiddenEvt = this.buildEvent('hidden')\n      this.emitEvent(hiddenEvt)\n      this.doRender = false\n    },\n    makeToast(h) {\n      // Render helper for generating the toast\n      // Assemble the header content\n      const $headerContent = []\n      const $title = this.normalizeSlot('toast-title', this.slotScope)\n      if ($title) {\n        $headerContent.push($title)\n      } else if (this.title) {\n        $headerContent.push(h('strong', { staticClass: 'mr-2' }, this.title))\n      }\n      if (!this.noCloseButton) {\n        $headerContent.push(\n          h(BButtonClose, {\n            staticClass: 'ml-auto mb-1',\n            on: {\n              click: () => {\n                this.hide()\n              }\n            }\n          })\n        )\n      }\n      // Assemble the header (if needed)\n      let $header = h()\n      if ($headerContent.length > 0) {\n        $header = h(\n          'header',\n          { staticClass: 'toast-header', class: this.headerClass },\n          $headerContent\n        )\n      }\n      // Toast body\n      const isLink = this.href || this.to\n      const $body = h(\n        isLink ? BLink : 'div',\n        {\n          staticClass: 'toast-body',\n          class: this.bodyClass,\n          props: isLink ? { to: this.to, href: this.href } : {},\n          on: isLink ? { click: this.onLinkClick } : {}\n        },\n        [this.normalizeSlot('default', this.slotScope) || h()]\n      )\n      // Build the toast\n      const $toast = h(\n        'div',\n        {\n          key: `toast-${this._uid}`,\n          ref: 'toast',\n          staticClass: 'toast',\n          class: this.toastClass,\n          attrs: {\n            ...this.$attrs,\n            tabindex: '0',\n            id: this.safeId()\n          }\n        },\n        [$header, $body]\n      )\n      return $toast\n    }\n  },\n  render(h) {\n    if (!this.doRender || !this.isMounted) {\n      return h()\n    }\n    const name = `b-toast-${this._uid}`\n    // If scoped styles are applied and the toast is not static,\n    // make sure the scoped style data attribute is applied\n    const scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {}\n\n    return h(\n      Portal,\n      {\n        props: {\n          name: name,\n          to: this.computedToaster,\n          order: this.order,\n          slim: true,\n          disabled: this.static\n        }\n      },\n      [\n        h(\n          'div',\n          {\n            key: name,\n            ref: 'b-toast',\n            staticClass: 'b-toast',\n            class: this.bToastClasses,\n            attrs: {\n              ...scopedStyleAttrs,\n              id: this.safeId('_toast_outer'),\n              role: this.isHiding ? null : this.isStatus ? 'status' : 'alert',\n              'aria-live': this.isHiding ? null : this.isStatus ? 'polite' : 'assertive',\n              'aria-atomic': this.isHiding ? null : 'true'\n            }\n          },\n          [\n            h(BVTransition, { props: { noFade: this.noFade }, on: this.transitionHandlers }, [\n              this.localShow ? this.makeToast(h) : h()\n            ])\n          ]\n        )\n      ]\n    )\n  }\n})\n","import KeyCodes from '../../utils/key-codes'\nimport { getAttr, hasAttr, isDisabled, matches, select, setAttr } from '../../utils/dom'\nimport { EVENT_OPTIONS_PASSIVE, eventOn, eventOff } from '../../utils/events'\nimport { isString } from '../../utils/inspect'\nimport { keys } from '../../utils/object'\n\n// Emitted show event for modal\nconst EVENT_SHOW = 'bv::show::modal'\n\n// Prop name we use to store info on root element\nconst PROPERTY = '__bv_modal_directive__'\n\nconst getTarget = ({ modifiers = {}, arg, value }) => {\n  // Try value, then arg, otherwise pick last modifier\n  return isString(value) ? value : isString(arg) ? arg : keys(modifiers).reverse()[0]\n}\n\nconst getTriggerElement = el => {\n  // If root element is a dropdown-item or nav-item, we\n  // need to target the inner link or button instead\n  return el && matches(el, '.dropdown-menu > li, li.nav-item') ? select('a, button', el) || el : el\n}\n\nconst setRole = trigger => {\n  // Ensure accessibility on non button elements\n  if (trigger && trigger.tagName !== 'BUTTON') {\n    // Only set a role if the trigger element doesn't have one\n    if (!hasAttr(trigger, 'role')) {\n      setAttr(trigger, 'role', 'button')\n    }\n    // Add a tabindex is not a button or link, and tabindex is not provided\n    if (trigger.tagName !== 'A' && !hasAttr(trigger, 'tabindex')) {\n      setAttr(trigger, 'tabindex', '0')\n    }\n  }\n}\n\nconst bind = (el, binding, vnode) => {\n  const target = getTarget(binding)\n  const trigger = getTriggerElement(el)\n  if (target && trigger) {\n    const handler = evt => {\n      // `currentTarget` is the element with the listener on it\n      const currentTarget = evt.currentTarget\n      if (!isDisabled(currentTarget)) {\n        const type = evt.type\n        const key = evt.keyCode\n        // Open modal only if trigger is not disabled\n        if (\n          type === 'click' ||\n          (type === 'keydown' && (key === KeyCodes.ENTER || key === KeyCodes.SPACE))\n        ) {\n          vnode.context.$root.$emit(EVENT_SHOW, target, currentTarget)\n        }\n      }\n    }\n    el[PROPERTY] = { handler, target, trigger }\n    // If element is not a button, we add `role=\"button\"` for accessibility\n    setRole(trigger)\n    // Listen for click events\n    eventOn(trigger, 'click', handler, EVENT_OPTIONS_PASSIVE)\n    if (trigger.tagName !== 'BUTTON' && getAttr(trigger, 'role') === 'button') {\n      // If trigger isn't a button but has role button,\n      // we also listen for `keydown.space` && `keydown.enter`\n      eventOn(trigger, 'keydown', handler, EVENT_OPTIONS_PASSIVE)\n    }\n  }\n}\n\nconst unbind = el => {\n  const oldProp = el[PROPERTY] || {}\n  const trigger = oldProp.trigger\n  const handler = oldProp.handler\n  if (trigger && handler) {\n    eventOff(trigger, 'click', handler, EVENT_OPTIONS_PASSIVE)\n    eventOff(trigger, 'keydown', handler, EVENT_OPTIONS_PASSIVE)\n    eventOff(el, 'click', handler, EVENT_OPTIONS_PASSIVE)\n    eventOff(el, 'keydown', handler, EVENT_OPTIONS_PASSIVE)\n  }\n  delete el[PROPERTY]\n}\n\nconst componentUpdated = (el, binding, vnode) => {\n  const oldProp = el[PROPERTY] || {}\n  const target = getTarget(binding)\n  const trigger = getTriggerElement(el)\n  if (target !== oldProp.target || trigger !== oldProp.trigger) {\n    // We bind and rebind if the target or trigger changes\n    unbind(el, binding, vnode)\n    bind(el, binding, vnode)\n  }\n  // If trigger element is not a button, ensure `role=\"button\"`\n  // is still set for accessibility\n  setRole(trigger)\n}\n\nconst updated = () => {}\n\n/*\n * Export our directive\n */\nexport const VBModal = {\n  inserted: componentUpdated,\n  updated,\n  componentUpdated,\n  unbind\n}\n","import Vue from '../../utils/vue'\nimport getScopId from '../../utils/get-scope-id'\nimport { isArray, arrayIncludes } from '../../utils/array'\nimport { getComponentConfig } from '../../utils/config'\nimport { isString, isUndefinedOrNull } from '../../utils/inspect'\nimport { HTMLElement, SVGElement } from '../../utils/safe-types'\nimport { BVTooltip } from './helpers/bv-tooltip'\n\nconst NAME = 'BTooltip'\n\n// @vue/component\nexport const BTooltip = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  props: {\n    title: {\n      type: String\n      // default: undefined\n    },\n    // Added in by BPopover\n    // content: {\n    //   type: String,\n    //   default: undefined\n    // },\n    target: {\n      // String ID of element, or element/component reference\n      // Or function that returns one of the above\n      type: [String, HTMLElement, SVGElement, Function, Object],\n      // default: undefined,\n      required: true\n    },\n    triggers: {\n      type: [String, Array],\n      default: 'hover focus'\n    },\n    placement: {\n      type: String,\n      default: 'top'\n    },\n    fallbackPlacement: {\n      type: [String, Array],\n      default: 'flip',\n      validator(value) {\n        return (\n          (isArray(value) && value.every(v => isString(v))) ||\n          arrayIncludes(['flip', 'clockwise', 'counterclockwise'], value)\n        )\n      }\n    },\n    variant: {\n      type: String,\n      default: () => getComponentConfig(NAME, 'variant')\n    },\n    customClass: {\n      type: String,\n      default: () => getComponentConfig(NAME, 'customClass')\n    },\n    delay: {\n      type: [Number, Object, String],\n      default: () => getComponentConfig(NAME, 'delay')\n    },\n    boundary: {\n      // String: scrollParent, window, or viewport\n      // Element: element reference\n      // Object: Vue component\n      type: [String, HTMLElement, Object],\n      default: () => getComponentConfig(NAME, 'boundary')\n    },\n    boundaryPadding: {\n      type: [Number, String],\n      default: () => getComponentConfig(NAME, 'boundaryPadding')\n    },\n    offset: {\n      type: [Number, String],\n      default: 0\n    },\n    noFade: {\n      type: Boolean,\n      default: false\n    },\n    container: {\n      // String: HTML ID of container, if null body is used (default)\n      // HTMLElement: element reference reference\n      // Object: Vue Component\n      type: [String, HTMLElement, Object]\n      // default: undefined\n    },\n    show: {\n      type: Boolean,\n      default: false\n    },\n    noninteractive: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    id: {\n      // ID to use for tooltip element\n      // If not provided on will automatically be generated\n      type: String,\n      default: null\n    }\n  },\n  data() {\n    return {\n      localShow: this.show,\n      localTitle: '',\n      localContent: ''\n    }\n  },\n  computed: {\n    templateData() {\n      // Data that will be passed to the template and popper\n      return {\n        // We use massaged versions of the title and content props/slots\n        title: this.localTitle,\n        content: this.localContent,\n        // Pass these props as is\n        target: this.target,\n        triggers: this.triggers,\n        placement: this.placement,\n        fallbackPlacement: this.fallbackPlacement,\n        variant: this.variant,\n        customClass: this.customClass,\n        container: this.container,\n        boundary: this.boundary,\n        boundaryPadding: this.boundaryPadding,\n        delay: this.delay,\n        offset: this.offset,\n        noFade: this.noFade,\n        interactive: !this.noninteractive,\n        disabled: this.disabled,\n        id: this.id\n      }\n    },\n    templateTitleContent() {\n      // Used to watch for changes to the title and content props\n      return {\n        title: this.title,\n        content: this.content\n      }\n    }\n  },\n  watch: {\n    show(show, oldVal) {\n      if (show !== oldVal && show !== this.localShow && this.$_bv_toolpop) {\n        if (show) {\n          this.$_bv_toolpop.show()\n        } else {\n          // We use `forceHide()` to override any active triggers\n          this.$_bv_toolpop.forceHide()\n        }\n      }\n    },\n    disabled(newVal) {\n      if (newVal) {\n        this.doDisable()\n      } else {\n        this.doEnable()\n      }\n    },\n    localShow(newVal) {\n      // TODO: May need to be done in a `$nextTick()`\n      this.$emit('update:show', newVal)\n    },\n    templateData() {\n      this.$nextTick(() => {\n        if (this.$_bv_toolpop) {\n          this.$_bv_toolpop.updateData(this.templateData)\n        }\n      })\n    },\n    // Watchers for title/content props (prop changes do not trigger the `updated()` hook)\n    templateTitleContent() {\n      this.$nextTick(this.updateContent)\n    }\n  },\n  created() {\n    // Non reactive properties\n    this.$_bv_toolpop = null\n  },\n  updated() {\n    // Update the `propData` object\n    // Done in a `$nextTick()` to ensure slot(s) have updated\n    this.$nextTick(this.updateContent)\n  },\n  beforeDestroy() {\n    // Shutdown our local event listeners\n    this.$off('open', this.doOpen)\n    this.$off('close', this.doClose)\n    this.$off('disable', this.doDisable)\n    this.$off('enable', this.doEnable)\n    // Destroy the tip instance\n    this.$_bv_toolpop && this.$_bv_toolpop.$destroy()\n    this.$_bv_toolpop = null\n  },\n  mounted() {\n    // Instantiate a new BVTooltip instance\n    // Done in a `$nextTick()` to ensure DOM has completed rendering\n    // so that target can be found\n    this.$nextTick(() => {\n      // Load the on demand child instance\n      const Component = this.getComponent()\n      // Ensure we have initial content\n      this.updateContent()\n      // Pass down the scoped style attribute if available\n      const scopeId = getScopId(this) || getScopId(this.$parent)\n      // Create the instance\n      const $toolpop = (this.$_bv_toolpop = new Component({\n        parent: this,\n        // Pass down the scoped style ID\n        _scopeId: scopeId || undefined\n      }))\n      // Set the initial data\n      $toolpop.updateData(this.templateData)\n      // Set listeners\n      $toolpop.$on('show', this.onShow)\n      $toolpop.$on('shown', this.onShown)\n      $toolpop.$on('hide', this.onHide)\n      $toolpop.$on('hidden', this.onHidden)\n      $toolpop.$on('disabled', this.onDisabled)\n      $toolpop.$on('enabled', this.onEnabled)\n      // Initially disabled?\n      if (this.disabled) {\n        // Initially disabled\n        this.doDisable()\n      }\n      // Listen to open signals from others\n      this.$on('open', this.doOpen)\n      // Listen to close signals from others\n      this.$on('close', this.doClose)\n      // Listen to disable signals from others\n      this.$on('disable', this.doDisable)\n      // Listen to enable signals from others\n      this.$on('enable', this.doEnable)\n      // Initially show tooltip?\n      if (this.localShow) {\n        this.$_bv_toolpop && this.$_bv_toolpop.show()\n      }\n    })\n  },\n  methods: {\n    getComponent() {\n      // Overridden by BPopover\n      return BVTooltip\n    },\n    updateContent() {\n      // Overridden by BPopover\n      // Tooltip: Default slot is `title`\n      // Popover: Default slot is `content`, `title` slot is title\n      // We pass a scoped slot function reference by default (Vue v2.6x)\n      // And pass the title prop as a fallback\n      this.setTitle(this.$scopedSlots.default || this.title)\n    },\n    // Helper methods for `updateContent()`\n    setTitle(val) {\n      val = isUndefinedOrNull(val) ? '' : val\n      // We only update the value if it has changed\n      if (this.localTitle !== val) {\n        this.localTitle = val\n      }\n    },\n    setContent(val) {\n      val = isUndefinedOrNull(val) ? '' : val\n      // We only update the value if it has changed\n      if (this.localContent !== val) {\n        this.localContent = val\n      }\n    },\n    // --- Template event handlers ---\n    onShow(bvEvt) {\n      // Placeholder\n      this.$emit('show', bvEvt)\n      if (bvEvt) {\n        this.localShow = !bvEvt.defaultPrevented\n      }\n    },\n    onShown(bvEvt) {\n      // Tip is now showing\n      this.localShow = true\n      this.$emit('shown', bvEvt)\n    },\n    onHide(bvEvt) {\n      this.$emit('hide', bvEvt)\n    },\n    onHidden(bvEvt) {\n      // Tip is no longer showing\n      this.$emit('hidden', bvEvt)\n      this.localShow = false\n    },\n    onDisabled(bvEvt) {\n      // Prevent possible endless loop if user mistakenly\n      // fires `disabled` instead of `disable`\n      if (bvEvt && bvEvt.type === 'disabled') {\n        this.$emit('update:disabled', true)\n        this.$emit('disabled', bvEvt)\n      }\n    },\n    onEnabled(bvEvt) {\n      // Prevent possible endless loop if user mistakenly\n      // fires `enabled` instead of `enable`\n      if (bvEvt && bvEvt.type === 'enabled') {\n        this.$emit('update:disabled', false)\n        this.$emit('enabled', bvEvt)\n      }\n    },\n    // --- Local event listeners ---\n    doOpen() {\n      !this.localShow && this.$_bv_toolpop && this.$_bv_toolpop.show()\n    },\n    doClose() {\n      this.localShow && this.$_bv_toolpop && this.$_bv_toolpop.hide()\n    },\n    doDisable() {\n      this.$_bv_toolpop && this.$_bv_toolpop.disable()\n    },\n    doEnable() {\n      this.$_bv_toolpop && this.$_bv_toolpop.enable()\n    }\n  },\n  render(h) {\n    // Always renders a comment node\n    // TODO:\n    //   Future: Possibly render a target slot (single root element)\n    //   which we can apply the listeners to (pass `this.$el` to BVTooltip)\n    return h()\n  }\n})\n","import Vue from '../../utils/vue'\nimport { PortalTarget, Wormhole } from 'portal-vue'\nimport { getComponentConfig } from '../../utils/config'\nimport { removeClass, requestAF } from '../../utils/dom'\nimport { warn } from '../../utils/warn'\n\n// --- Constants ---\n\nconst NAME = 'BToaster'\n\nexport const props = {\n  name: {\n    type: String,\n    required: true\n  },\n  ariaLive: {\n    type: String,\n    default: () => getComponentConfig(NAME, 'ariaLive')\n  },\n  ariaAtomic: {\n    type: String,\n    default: () => getComponentConfig(NAME, 'ariaAtomic') // Allowed: 'true' or 'false' or null\n  },\n  role: {\n    // Aria role\n    type: String,\n    default: () => getComponentConfig(NAME, 'role')\n  }\n  /*\n  transition: {\n    type: [Boolean, String, Object],\n    default: false\n  }\n  */\n}\n\n// @vue/component\nexport const DefaultTransition = /*#__PURE__*/ Vue.extend({\n  data() {\n    return {\n      // Transition classes base name\n      name: 'b-toaster'\n    }\n  },\n  methods: {\n    onAfterEnter(el) {\n      // Handle bug where enter-to class is not removed.\n      // Bug is related to portal-vue and transition-groups.\n      requestAF(() => {\n        removeClass(el, `${this.name}-enter-to`)\n        // The *-move class is also stuck on elements that moved,\n        // but there are no javascript hooks to handle after move.\n      })\n    }\n  },\n  render(h) {\n    return h(\n      'transition-group',\n      {\n        props: { tag: 'div', name: this.name },\n        on: { afterEnter: this.onAfterEnter }\n      },\n      this.$slots.default\n    )\n  }\n})\n\n// @vue/component\nexport const BToaster = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  props,\n  data() {\n    return {\n      // We don't render on SSR or if a an existing target found\n      doRender: false,\n      dead: false,\n      // Toaster names cannot change once created\n      staticName: this.name\n    }\n  },\n  beforeMount() {\n    this.staticName = this.name\n    /* istanbul ignore if */\n    if (Wormhole.hasTarget(this.staticName)) {\n      warn(\n        `A \"<portal-target>\" with name \"${this.name}\" already exists in the document.`,\n        'BToaster'\n      )\n      this.dead = true\n    } else {\n      this.doRender = true\n      this.$once('hook:beforeDestroy', () => {\n        // Let toasts made with `this.$bvToast.toast()` know that this toaster\n        // is being destroyed and should should also destroy/hide themselves\n        this.$root.$emit('bv::toaster::destroyed', this.staticName)\n      })\n    }\n  },\n  destroyed() {\n    // Remove from DOM if needed\n    /* istanbul ignore next: difficult to test */\n    if (this.$el && this.$el.parentNode) {\n      this.$el.parentNode.removeChild(this.$el)\n    }\n  },\n  render(h) {\n    let $toaster = h('div', { class: ['d-none', { 'b-dead-toaster': this.dead }] })\n    if (this.doRender) {\n      const $target = h(PortalTarget, {\n        staticClass: 'b-toaster-slot',\n        props: {\n          name: this.staticName,\n          multiple: true,\n          tag: 'div',\n          slim: false,\n          // transition: this.transition || DefaultTransition\n          transition: DefaultTransition\n        }\n      })\n      $toaster = h(\n        'div',\n        {\n          staticClass: 'b-toaster',\n          class: [this.staticName],\n          attrs: {\n            id: this.staticName,\n            role: this.role || null, // Fallback to null to make sure attribute doesn't exist\n            'aria-live': this.ariaLive,\n            'aria-atomic': this.ariaAtomic\n          }\n        },\n        [$target]\n      )\n    }\n    return $toaster\n  }\n})\n","import getScopId from '../../utils/get-scope-id'\nimport identity from '../../utils/identity'\nimport looseEqual from '../../utils/loose-equal'\nimport { concat } from '../../utils/array'\nimport { getComponentConfig } from '../../utils/config'\nimport { isBrowser } from '../../utils/env'\nimport {\n  isFunction,\n  isNumber,\n  isPlainObject,\n  isString,\n  isUndefined,\n  isUndefinedOrNull\n} from '../../utils/inspect'\nimport { keys } from '../../utils/object'\nimport { BVPopover } from '../../components/popover/helpers/bv-popover'\n\n// Key which we use to store tooltip object on element\nconst BV_POPOVER = '__BV_Popover__'\n\n// Default trigger\nconst DefaultTrigger = 'click'\n\n// Valid event triggers\nconst validTriggers = {\n  focus: true,\n  hover: true,\n  click: true,\n  blur: true,\n  manual: true\n}\n\n// Directive modifier test regular expressions. Pre-compile for performance\nconst htmlRE = /^html$/i\nconst noFadeRE = /^nofade$/i\nconst placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i\nconst boundaryRE = /^(window|viewport|scrollParent)$/i\nconst delayRE = /^d\\d+$/i\nconst delayShowRE = /^ds\\d+$/i\nconst delayHideRE = /^dh\\d+$/i\nconst offsetRE = /^o-?\\d+$/i\nconst variantRE = /^v-.+$/i\nconst spacesRE = /\\s+/\n\n// Build a Popover config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\nconst parseBindings = (bindings, vnode) => /* istanbul ignore next: not easy to test */ {\n  // We start out with a basic config\n  const NAME = 'BPopover'\n  let config = {\n    title: undefined,\n    content: undefined,\n    trigger: '', // Default set below if needed\n    placement: 'right',\n    fallbackPlacement: 'flip',\n    container: false, // Default of body\n    animation: true,\n    offset: 0,\n    disabled: false,\n    id: null,\n    html: false,\n    delay: getComponentConfig(NAME, 'delay'),\n    boundary: String(getComponentConfig(NAME, 'boundary')),\n    boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,\n    variant: getComponentConfig(NAME, 'variant'),\n    customClass: getComponentConfig(NAME, 'customClass')\n  }\n\n  // Process `bindings.value`\n  if (isString(bindings.value) || isNumber(bindings.value)) {\n    // Value is popover content (html optionally supported)\n    config.content = bindings.value\n  } else if (isFunction(bindings.value)) {\n    // Content generator function\n    config.content = bindings.value\n  } else if (isPlainObject(bindings.value)) {\n    // Value is config object, so merge\n    config = { ...config, ...bindings.value }\n  }\n\n  // If argument, assume element ID of container element\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.container = `#${bindings.arg}`\n  }\n\n  // If title is not provided, try title attribute\n  if (isUndefined(config.title)) {\n    // Try attribute\n    const data = vnode.data || {}\n    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined\n  }\n\n  // Normalize delay\n  if (!isPlainObject(config.delay)) {\n    config.delay = {\n      show: parseInt(config.delay, 10) || 0,\n      hide: parseInt(config.delay, 10) || 0\n    }\n  }\n\n  // Process modifiers\n  keys(bindings.modifiers).forEach(mod => {\n    if (htmlRE.test(mod)) {\n      // Title/content allows HTML\n      config.html = true\n    } else if (noFadeRE.test(mod)) {\n      // No animation\n      config.animation = false\n    } else if (placementRE.test(mod)) {\n      // Placement of popover\n      config.placement = mod\n    } else if (boundaryRE.test(mod)) {\n      // Boundary of popover\n      mod = mod === 'scrollparent' ? 'scrollParent' : mod\n      config.boundary = mod\n    } else if (delayRE.test(mod)) {\n      // Delay value\n      const delay = parseInt(mod.slice(1), 10) || 0\n      config.delay.show = delay\n      config.delay.hide = delay\n    } else if (delayShowRE.test(mod)) {\n      // Delay show value\n      config.delay.show = parseInt(mod.slice(2), 10) || 0\n    } else if (delayHideRE.test(mod)) {\n      // Delay hide value\n      config.delay.hide = parseInt(mod.slice(2), 10) || 0\n    } else if (offsetRE.test(mod)) {\n      // Offset value, negative allowed\n      config.offset = parseInt(mod.slice(1), 10) || 0\n    } else if (variantRE.test(mod)) {\n      // Variant\n      config.variant = mod.slice(2) || null\n    }\n  })\n\n  // Special handling of event trigger modifiers trigger is\n  // a space separated list\n  const selectedTriggers = {}\n\n  // Parse current config object trigger\n  concat(config.trigger || '')\n    .filter(identity)\n    .join(' ')\n    .trim()\n    .toLowerCase()\n    .split(spacesRE)\n    .forEach(trigger => {\n      if (validTriggers[trigger]) {\n        selectedTriggers[trigger] = true\n      }\n    })\n\n  // Parse modifiers for triggers\n  keys(bindings.modifiers).forEach(mod => {\n    mod = mod.toLowerCase()\n    if (validTriggers[mod]) {\n      // If modifier is a valid trigger\n      selectedTriggers[mod] = true\n    }\n  })\n\n  // Sanitize triggers\n  config.trigger = keys(selectedTriggers).join(' ')\n  if (config.trigger === 'blur') {\n    // Blur by itself is useless, so convert it to 'focus'\n    config.trigger = 'focus'\n  }\n  if (!config.trigger) {\n    // Use default trigger\n    config.trigger = DefaultTrigger\n  }\n\n  return config\n}\n\n// Add or update Popover on our element\nconst applyPopover = (el, bindings, vnode) => {\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return\n  }\n  const config = parseBindings(bindings, vnode)\n  if (!el[BV_POPOVER]) {\n    const $parent = vnode.context\n    el[BV_POPOVER] = new BVPopover({\n      parent: $parent,\n      // Add the parent's scoped style attribute data\n      _scopeId: getScopId($parent, undefined)\n    })\n    el[BV_POPOVER].__bv_prev_data__ = {}\n    el[BV_POPOVER].$on('show', () => /* istanbul ignore next: for now */ {\n      // Before showing the popover, we update the title\n      // and content if they are functions\n      const data = {}\n      if (isFunction(config.title)) {\n        data.title = config.title(el)\n      }\n      if (isFunction(config.content)) {\n        data.content = config.content(el)\n      }\n      if (keys(data).length > 0) {\n        el[BV_POPOVER].updateData(data)\n      }\n    })\n  }\n  const data = {\n    title: config.title,\n    content: config.content,\n    triggers: config.trigger,\n    placement: config.placement,\n    fallbackPlacement: config.fallbackPlacement,\n    variant: config.variant,\n    customClass: config.customClass,\n    container: config.container,\n    boundary: config.boundary,\n    delay: config.delay,\n    offset: config.offset,\n    noFade: !config.animation,\n    id: config.id,\n    disabled: config.disabled,\n    html: config.html\n  }\n  const oldData = el[BV_POPOVER].__bv_prev_data__\n  el[BV_POPOVER].__bv_prev_data__ = data\n  if (!looseEqual(data, oldData)) {\n    // We only update the instance if data has changed\n    const newData = {\n      target: el\n    }\n    keys(data).forEach(prop => {\n      // We only pass data properties that have changed\n      if (data[prop] !== oldData[prop]) {\n        // If title/content is a function, we execute it here\n        newData[prop] =\n          (prop === 'title' || prop === 'content') && isFunction(data[prop])\n            ? data[prop](el)\n            : data[prop]\n      }\n    })\n    el[BV_POPOVER].updateData(newData)\n  }\n}\n\n// Remove Popover from our element\nconst removePopover = el => {\n  if (el[BV_POPOVER]) {\n    el[BV_POPOVER].$destroy()\n    el[BV_POPOVER] = null\n  }\n  delete el[BV_POPOVER]\n}\n\n// Export our directive\nexport const VBPopover = {\n  bind(el, bindings, vnode) {\n    applyPopover(el, bindings, vnode)\n  },\n  // We use `componentUpdated` here instead of `update`, as the former\n  // waits until the containing component and children have finished updating\n  componentUpdated(el, bindings, vnode) {\n    // Performed in a `$nextTick()` to prevent endless render/update loops\n    vnode.context.$nextTick(() => {\n      applyPopover(el, bindings, vnode)\n    })\n  },\n  unbind(el) {\n    removePopover(el)\n  }\n}\n","import { VBPopover } from './popover'\nimport { pluginFactory } from '../../utils/plugins'\n\nconst VBPopoverPlugin = /*#__PURE__*/ pluginFactory({\n  directives: { VBPopover }\n})\n\nexport { VBPopoverPlugin, VBPopover }\n","/**\n * Plugin for adding `$bvToast` property to all Vue instances\n */\n\nimport { concat } from '../../../utils/array'\nimport { getComponentConfig } from '../../../utils/config'\nimport { requestAF } from '../../../utils/dom'\nimport { isUndefined, isString } from '../../../utils/inspect'\nimport {\n  assign,\n  defineProperties,\n  defineProperty,\n  keys,\n  omit,\n  readonlyDescriptor\n} from '../../../utils/object'\nimport { pluginFactory } from '../../../utils/plugins'\nimport { warn, warnNotClient } from '../../../utils/warn'\nimport { BToast, props as toastProps } from '../toast'\n\n// --- Constants ---\n\nconst PROP_NAME = '$bvToast'\nconst PROP_NAME_PRIV = '_bv__toast'\n\n// Base toast props that are allowed\n// Some may be ignored or overridden on some message boxes\n// Prop ID is allowed, but really only should be used for testing\n// We need to add it in explicitly as it comes from the `idMixin`\nconst BASE_PROPS = ['id', ...keys(omit(toastProps, ['static', 'visible']))]\n\n// Map prop names to toast slot names\nconst propsToSlots = {\n  toastContent: 'default',\n  title: 'toast-title'\n}\n\n// --- Utility methods ---\n\n// Method to filter only recognized props that are not undefined\nconst filterOptions = options => {\n  return BASE_PROPS.reduce((memo, key) => {\n    if (!isUndefined(options[key])) {\n      memo[key] = options[key]\n    }\n    return memo\n  }, {})\n}\n\n// Method to install `$bvToast` VM injection\nconst plugin = Vue => {\n  // Create a private sub-component constructor that\n  // extends BToast and self-destructs after hidden\n  // @vue/component\n  const BToastPop = Vue.extend({\n    name: 'BToastPop',\n    extends: BToast,\n    destroyed() {\n      // Make sure we not in document any more\n      if (this.$el && this.$el.parentNode) {\n        this.$el.parentNode.removeChild(this.$el)\n      }\n    },\n    mounted() {\n      const self = this\n      // Self destruct handler\n      const handleDestroy = () => {\n        // Ensure the toast has been force hidden\n        self.localShow = false\n        self.doRender = false\n        self.$nextTick(() => {\n          self.$nextTick(() => {\n            // In a `requestAF()` to release control back to application\n            // and to allow the portal-target time to remove the content\n            requestAF(() => {\n              self.$destroy()\n            })\n          })\n        })\n      }\n      // Self destruct if parent destroyed\n      this.$parent.$once('hook:destroyed', handleDestroy)\n      // Self destruct after hidden\n      this.$once('hidden', handleDestroy)\n      // Self destruct when toaster is destroyed\n      this.listenOnRoot('bv::toaster::destroyed', toaster => {\n        /* istanbul ignore next: hard to test */\n        if (toaster === self.toaster) {\n          handleDestroy()\n        }\n      })\n    }\n  })\n\n  // Private method to generate the on-demand toast\n  const makeToast = (props, $parent) => {\n    if (warnNotClient(PROP_NAME)) {\n      /* istanbul ignore next */\n      return\n    }\n    // Create an instance of `BToastPop` component\n    const toast = new BToastPop({\n      // We set parent as the local VM so these toasts can emit events on the\n      // app `$root`, and it ensures `BToast` is destroyed when parent is destroyed\n      parent: $parent,\n      propsData: {\n        ...filterOptions(getComponentConfig('BToast') || {}),\n        // Add in (filtered) user supplied props\n        ...omit(props, keys(propsToSlots)),\n        // Props that can't be overridden\n        static: false,\n        visible: true\n      }\n    })\n    // Convert certain props to slots\n    keys(propsToSlots).forEach(prop => {\n      let value = props[prop]\n      if (!isUndefined(value)) {\n        // Can be a string, or array of VNodes\n        if (prop === 'title' && isString(value)) {\n          // Special case for title if it is a string, we wrap in a <strong>\n          value = [$parent.$createElement('strong', { class: 'mr-2' }, value)]\n        }\n        toast.$slots[propsToSlots[prop]] = concat(value)\n      }\n    })\n    // Create a mount point (a DIV) and mount it (which triggers the show)\n    const div = document.createElement('div')\n    document.body.appendChild(div)\n    toast.$mount(div)\n  }\n\n  // Declare BvToast instance property class\n  class BvToast {\n    constructor(vm) {\n      // Assign the new properties to this instance\n      assign(this, { _vm: vm, _root: vm.$root })\n      // Set these properties as read-only and non-enumerable\n      defineProperties(this, {\n        _vm: readonlyDescriptor(),\n        _root: readonlyDescriptor()\n      })\n    }\n\n    // --- Public Instance methods ---\n\n    // Opens a user defined toast and returns immediately\n    toast(content, options = {}) {\n      if (!content || warnNotClient(PROP_NAME)) {\n        /* istanbul ignore next */\n        return\n      }\n      makeToast({ ...filterOptions(options), toastContent: content }, this._vm)\n    }\n\n    // shows a `<b-toast>` component with the specified ID\n    show(id) {\n      if (id) {\n        this._root.$emit('bv::show::toast', id)\n      }\n    }\n\n    // Hide a toast with specified ID, or if not ID all toasts\n    hide(id = null) {\n      this._root.$emit('bv::hide::toast', id)\n    }\n  }\n\n  // Add our instance mixin\n  Vue.mixin({\n    beforeCreate() {\n      // Because we need access to `$root` for `$emits`, and VM for parenting,\n      // we have to create a fresh instance of `BvToast` for each VM\n      this[PROP_NAME_PRIV] = new BvToast(this)\n    }\n  })\n\n  // Define our read-only `$bvToast` instance property\n  // Placed in an if just in case in HMR mode\n  // eslint-disable-next-line no-prototype-builtins\n  if (!Vue.prototype.hasOwnProperty(PROP_NAME)) {\n    defineProperty(Vue.prototype, PROP_NAME, {\n      get() {\n        /* istanbul ignore next */\n        if (!this || !this[PROP_NAME_PRIV]) {\n          warn(`\"${PROP_NAME}\" must be accessed from a Vue instance \"this\" context.`, 'BToast')\n        }\n        return this[PROP_NAME_PRIV]\n      }\n    })\n  }\n}\n\nexport const BVToastPlugin = /*#__PURE__*/ pluginFactory({\n  plugins: { plugin }\n})\n","import Vue from '../../utils/vue'\nimport { getComponentConfig } from '../../utils/config'\nimport { htmlOrText } from '../../utils/html'\nimport { isBoolean } from '../../utils/inspect'\nimport { toFixed, toFloat, toInteger } from '../../utils/number'\nimport { toString } from '../../utils/string'\nimport normalizeSlotMixin from '../../mixins/normalize-slot'\n\nconst NAME = 'BProgressBar'\n\n// @vue/component\nexport const BProgressBar = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  mixins: [normalizeSlotMixin],\n  inject: {\n    bvProgress: {\n      default() /* istanbul ignore next */ {\n        return {}\n      }\n    }\n  },\n  props: {\n    value: {\n      type: [Number, String],\n      default: 0\n    },\n    label: {\n      type: String,\n      default: null\n    },\n    labelHtml: {\n      type: String\n    },\n    // $parent (this.bvProgress) prop values may take precedence over the following props\n    // Which is why they are defaulted to null\n    max: {\n      type: [Number, String],\n      default: null\n    },\n    precision: {\n      type: [Number, String],\n      default: null\n    },\n    variant: {\n      type: String,\n      default: () => getComponentConfig(NAME, 'variant')\n    },\n    striped: {\n      type: Boolean,\n      default: null\n    },\n    animated: {\n      type: Boolean,\n      default: null\n    },\n    showProgress: {\n      type: Boolean,\n      default: null\n    },\n    showValue: {\n      type: Boolean,\n      default: null\n    }\n  },\n  computed: {\n    progressBarClasses() {\n      return [\n        this.computedVariant ? `bg-${this.computedVariant}` : '',\n        this.computedStriped || this.computedAnimated ? 'progress-bar-striped' : '',\n        this.computedAnimated ? 'progress-bar-animated' : ''\n      ]\n    },\n    progressBarStyles() {\n      return {\n        width: 100 * (this.computedValue / this.computedMax) + '%'\n      }\n    },\n    computedValue() {\n      return toFloat(this.value) || 0\n    },\n    computedMax() {\n      // Prefer our max over parent setting\n      const max = toFloat(this.max)\n      return isNaN(max) ? toFloat(this.bvProgress.max) || 100 : max\n    },\n    computedPrecision() {\n      // Prefer our precision over parent setting\n      const precision = toInteger(this.precision)\n      return isNaN(precision) ? toInteger(this.bvProgress.precision) || 0 : precision\n    },\n    computedProgress() {\n      const precision = this.computedPrecision\n      const p = Math.pow(10, precision)\n      return toFixed((100 * p * this.computedValue) / this.computedMax / p, precision)\n    },\n    computedVariant() {\n      // Prefer our variant over parent setting\n      return this.variant || this.bvProgress.variant\n    },\n    computedStriped() {\n      // Prefer our striped over parent setting\n      return isBoolean(this.striped) ? this.striped : this.bvProgress.striped || false\n    },\n    computedAnimated() {\n      // Prefer our animated over parent setting\n      return isBoolean(this.animated) ? this.animated : this.bvProgress.animated || false\n    },\n    computedShowProgress() {\n      // Prefer our showProgress over parent setting\n      return isBoolean(this.showProgress)\n        ? this.showProgress\n        : this.bvProgress.showProgress || false\n    },\n    computedShowValue() {\n      // Prefer our showValue over parent setting\n      return isBoolean(this.showValue) ? this.showValue : this.bvProgress.showValue || false\n    }\n  },\n  render(h) {\n    let childNodes = h()\n    if (this.hasNormalizedSlot('default')) {\n      childNodes = this.normalizeSlot('default')\n    } else if (this.label || this.labelHtml) {\n      childNodes = h('span', { domProps: htmlOrText(this.labelHtml, this.label) })\n    } else if (this.computedShowProgress) {\n      childNodes = this.computedProgress\n    } else if (this.computedShowValue) {\n      childNodes = toFixed(this.computedValue, this.computedPrecision)\n    }\n    return h(\n      'div',\n      {\n        staticClass: 'progress-bar',\n        class: this.progressBarClasses,\n        style: this.progressBarStyles,\n        attrs: {\n          role: 'progressbar',\n          'aria-valuemin': '0',\n          'aria-valuemax': toString(this.computedMax),\n          'aria-valuenow': toFixed(this.computedValue, this.computedPrecision)\n        }\n      },\n      [childNodes]\n    )\n  }\n})\n","import Vue from '../../utils/vue'\nimport { getComponentConfig } from '../../utils/config'\nimport normalizeSlotMixin from '../../mixins/normalize-slot'\nimport { BProgressBar } from './progress-bar'\n\nconst NAME = 'BProgress'\n\n// @vue/component\nexport const BProgress = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  mixins: [normalizeSlotMixin],\n  provide() {\n    return { bvProgress: this }\n  },\n  props: {\n    // These props can be inherited via the child b-progress-bar(s)\n    variant: {\n      type: String,\n      default: () => getComponentConfig(NAME, 'variant')\n    },\n    striped: {\n      type: Boolean,\n      default: false\n    },\n    animated: {\n      type: Boolean,\n      default: false\n    },\n    height: {\n      type: String,\n      default: null\n    },\n    precision: {\n      type: [Number, String],\n      default: 0\n    },\n    showProgress: {\n      type: Boolean,\n      default: false\n    },\n    showValue: {\n      type: Boolean,\n      default: false\n    },\n    max: {\n      type: [Number, String],\n      default: 100\n    },\n    // This prop is not inherited by child b-progress-bar(s)\n    value: {\n      type: [Number, String],\n      default: 0\n    }\n  },\n  computed: {\n    progressHeight() {\n      return { height: this.height || null }\n    }\n  },\n  render(h) {\n    let childNodes = this.normalizeSlot('default')\n    if (!childNodes) {\n      childNodes = h(BProgressBar, {\n        props: {\n          value: this.value,\n          max: this.max,\n          precision: this.precision,\n          variant: this.variant,\n          animated: this.animated,\n          striped: this.striped,\n          showProgress: this.showProgress,\n          showValue: this.showValue\n        }\n      })\n    }\n    return h('div', { class: ['progress'], style: this.progressHeight }, [childNodes])\n  }\n})\n","import { BProgress } from './progress'\nimport { BProgressBar } from './progress-bar'\nimport { pluginFactory } from '../../utils/plugins'\n\nconst ProgressPlugin = /*#__PURE__*/ pluginFactory({\n  components: {\n    BProgress,\n    BProgressBar\n  }\n})\n\nexport { ProgressPlugin, BProgress, BProgressBar }\n","import Vue from '../../utils/vue'\nimport identity from '../../utils/identity'\nimport KeyCodes from '../../utils/key-codes'\nimport looseEqual from '../../utils/loose-equal'\nimport observeDom from '../../utils/observe-dom'\nimport stableSort from '../../utils/stable-sort'\nimport { arrayIncludes, concat } from '../../utils/array'\nimport { BvEvent } from '../../utils/bv-event.class'\nimport { requestAF, selectAll } from '../../utils/dom'\nimport { isEvent } from '../../utils/inspect'\nimport { omit } from '../../utils/object'\nimport idMixin from '../../mixins/id'\nimport normalizeSlotMixin from '../../mixins/normalize-slot'\nimport { BLink } from '../link/link'\nimport { BNav, props as BNavProps } from '../nav/nav'\n\n// -- Constants --\n\nconst navProps = omit(BNavProps, ['tabs', 'isNavBar', 'cardHeader'])\n\n// -- Utils --\n\n// Filter function to filter out disabled tabs\nconst notDisabled = tab => !tab.disabled\n\n// --- Helper components ---\n\n// @vue/component\nconst BTabButtonHelper = /*#__PURE__*/ Vue.extend({\n  name: 'BTabButtonHelper',\n  inject: {\n    bvTabs: {\n      default() /* istanbul ignore next */ {\n        return {}\n      }\n    }\n  },\n  props: {\n    // Reference to the child <b-tab> instance\n    tab: { default: null },\n    tabs: {\n      type: Array,\n      default() /* istanbul ignore next */ {\n        return []\n      }\n    },\n    id: { type: String, default: null },\n    controls: { type: String, default: null },\n    tabIndex: { type: Number, default: null },\n    posInSet: { type: Number, default: null },\n    setSize: { type: Number, default: null },\n    noKeyNav: { type: Boolean, default: false }\n  },\n  methods: {\n    focus() {\n      if (this.$refs && this.$refs.link && this.$refs.link.focus) {\n        this.$refs.link.focus()\n      }\n    },\n    handleEvt(evt) {\n      const stop = () => {\n        evt.preventDefault()\n        evt.stopPropagation()\n      }\n      if (this.tab.disabled) {\n        /* istanbul ignore next */\n        return\n      }\n      const type = evt.type\n      const key = evt.keyCode\n      const shift = evt.shiftKey\n      if (type === 'click') {\n        stop()\n        this.$emit('click', evt)\n      } else if (type === 'keydown' && key === KeyCodes.SPACE) {\n        // For ARIA tabs the SPACE key will also trigger a click/select\n        // Even with keyboard navigation disabled, SPACE should \"click\" the button\n        // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323\n        stop()\n        this.$emit('click', evt)\n      } else if (type === 'keydown' && !this.noKeyNav) {\n        // For keyboard navigation\n        if (key === KeyCodes.UP || key === KeyCodes.LEFT || key === KeyCodes.HOME) {\n          stop()\n          if (shift || key === KeyCodes.HOME) {\n            this.$emit('first', evt)\n          } else {\n            this.$emit('prev', evt)\n          }\n        } else if (key === KeyCodes.DOWN || key === KeyCodes.RIGHT || key === KeyCodes.END) {\n          stop()\n          if (shift || key === KeyCodes.END) {\n            this.$emit('last', evt)\n          } else {\n            this.$emit('next', evt)\n          }\n        }\n      }\n    }\n  },\n  render(h) {\n    const link = h(\n      BLink,\n      {\n        ref: 'link',\n        staticClass: 'nav-link',\n        class: [\n          {\n            active: this.tab.localActive && !this.tab.disabled,\n            disabled: this.tab.disabled\n          },\n          this.tab.titleLinkClass,\n          // Apply <b-tabs> `activeNavItemClass` styles when the tab is active\n          this.tab.localActive ? this.bvTabs.activeNavItemClass : null\n        ],\n        props: { disabled: this.tab.disabled },\n        attrs: {\n          ...this.tab.titleLinkAttributes,\n          role: 'tab',\n          id: this.id,\n          // Roving tab index when keynav enabled\n          tabindex: this.tabIndex,\n          'aria-selected': this.tab.localActive && !this.tab.disabled ? 'true' : 'false',\n          'aria-setsize': this.setSize,\n          'aria-posinset': this.posInSet,\n          'aria-controls': this.controls\n        },\n        on: {\n          click: this.handleEvt,\n          keydown: this.handleEvt\n        }\n      },\n      [this.tab.normalizeSlot('title') || this.tab.title]\n    )\n    return h(\n      'li',\n      {\n        staticClass: 'nav-item',\n        class: [this.tab.titleItemClass],\n        attrs: { role: 'presentation' }\n      },\n      [link]\n    )\n  }\n})\n\n// @vue/component\nexport const BTabs = /*#__PURE__*/ Vue.extend({\n  name: 'BTabs',\n  mixins: [idMixin, normalizeSlotMixin],\n  provide() {\n    return {\n      bvTabs: this\n    }\n  },\n  model: {\n    prop: 'value',\n    event: 'input'\n  },\n  props: {\n    ...navProps,\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    card: {\n      type: Boolean,\n      default: false\n    },\n    end: {\n      // Synonym for 'bottom'\n      type: Boolean,\n      default: false\n    },\n    noFade: {\n      type: Boolean,\n      default: false\n    },\n    noNavStyle: {\n      type: Boolean,\n      default: false\n    },\n    noKeyNav: {\n      type: Boolean,\n      default: false\n    },\n    lazy: {\n      // This prop is sniffed by the <b-tab> child\n      type: Boolean,\n      default: false\n    },\n    contentClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    navClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    navWrapperClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    activeNavItemClass: {\n      // Only applied to the currently active <b-nav-item>\n      type: [String, Array, Object],\n      default: null\n    },\n    activeTabClass: {\n      // Only applied to the currently active <b-tab>\n      // This prop is sniffed by the <b-tab> child\n      type: [String, Array, Object],\n      default: null\n    },\n    value: {\n      // v-model\n      type: Number,\n      default: null\n    }\n  },\n  data() {\n    let tabIdx = parseInt(this.value, 10)\n    tabIdx = isNaN(tabIdx) ? -1 : tabIdx\n    return {\n      // Index of current tab\n      currentTab: tabIdx,\n      // Array of direct child <b-tab> instances, in DOM order\n      tabs: [],\n      // Array of child instances registered (for triggering reactive updates)\n      registeredTabs: [],\n      // Flag to know if we are mounted or not\n      isMounted: false\n    }\n  },\n  computed: {\n    fade() {\n      // This computed prop is sniffed by the tab child\n      return !this.noFade\n    },\n    localNavClass() {\n      const classes = []\n      if (this.card && this.vertical) {\n        classes.push('card-header', 'h-100', 'border-bottom-0', 'rounded-0')\n      }\n      return [...classes, this.navClass]\n    }\n  },\n  watch: {\n    currentTab(newVal) {\n      let index = -1\n      // Ensure only one tab is active at most\n      this.tabs.forEach((tab, idx) => {\n        if (newVal === idx && !tab.disabled) {\n          tab.localActive = true\n          index = idx\n        } else {\n          tab.localActive = false\n        }\n      })\n      // Update the v-model\n      this.$emit('input', index)\n    },\n    value(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        newVal = parseInt(newVal, 10)\n        newVal = isNaN(newVal) ? -1 : newVal\n        oldVal = parseInt(oldVal, 10) || 0\n        const tabs = this.tabs\n        if (tabs[newVal] && !tabs[newVal].disabled) {\n          this.activateTab(tabs[newVal])\n        } else {\n          // Try next or prev tabs\n          if (newVal < oldVal) {\n            this.previousTab()\n          } else {\n            this.nextTab()\n          }\n        }\n      }\n    },\n    registeredTabs() {\n      // Each b-tab will register/unregister itself.\n      // We use this to detect when tabs are added/removed\n      // to trigger the update of the tabs.\n      this.$nextTick(() => {\n        requestAF(() => {\n          this.updateTabs()\n        })\n      })\n    },\n    tabs(newVal, oldVal) {\n      // If tabs added, removed, or re-ordered, we emit a `changed` event.\n      // We use `tab._uid` instead of `tab.safeId()`, as the later is changed\n      // in a nextTick if no explicit ID is provided, causing duplicate emits.\n      if (!looseEqual(newVal.map(t => t._uid), oldVal.map(t => t._uid))) {\n        // In a nextTick to ensure currentTab has been set first.\n        this.$nextTick(() => {\n          // We emit shallow copies of the new and old arrays of tabs, to\n          // prevent users from potentially mutating the internal arrays.\n          this.$emit('changed', newVal.slice(), oldVal.slice())\n        })\n      }\n    },\n    isMounted(newVal) {\n      // Trigger an update after mounted.  Needed for tabs inside lazy modals.\n      if (newVal) {\n        requestAF(() => {\n          this.updateTabs()\n        })\n      }\n      // Enable or disable the observer\n      this.setObserver(newVal)\n    }\n  },\n  created() {\n    const tabIdx = parseInt(this.value, 10)\n    this.currentTab = isNaN(tabIdx) ? -1 : tabIdx\n    this._bvObserver = null\n    // For SSR and to make sure only a single tab is shown on mount\n    // We wrap this in a `$nextTick()` to ensure the child tabs have been created\n    this.$nextTick(() => {\n      this.updateTabs()\n    })\n  },\n  mounted() {\n    // Call `updateTabs()` just in case...\n    this.updateTabs()\n    this.$nextTick(() => {\n      // Flag we are now mounted and to switch to DOM for tab probing.\n      // As this.$slots.default appears to lie about component instances\n      // after b-tabs is destroyed and re-instantiated.\n      // And this.$children does not respect DOM order.\n      this.isMounted = true\n    })\n  },\n  deactivated() /* istanbul ignore next */ {\n    this.isMounted = false\n  },\n  activated() /* istanbul ignore next */ {\n    const tabIdx = parseInt(this.value, 10)\n    this.currentTab = isNaN(tabIdx) ? -1 : tabIdx\n    this.$nextTick(() => {\n      this.updateTabs()\n      this.isMounted = true\n    })\n  },\n  beforeDestroy() {\n    this.isMounted = false\n  },\n  destroyed() {\n    // Ensure no references to child instances exist\n    this.tabs = []\n  },\n  methods: {\n    registerTab(tab) {\n      if (!arrayIncludes(this.registeredTabs, tab)) {\n        this.registeredTabs.push(tab)\n        tab.$once('hook:destroyed', () => {\n          this.unregisterTab(tab)\n        })\n      }\n    },\n    unregisterTab(tab) {\n      this.registeredTabs = this.registeredTabs.slice().filter(t => t !== tab)\n    },\n    setObserver(on) {\n      // DOM observer is needed to detect changes in order of tabs\n      if (on) {\n        // Make sure no existing observer running\n        this.setObserver(false)\n        const self = this\n        /* istanbul ignore next: difficult to test mutation observer in JSDOM */\n        const handler = () => {\n          // We delay the update to ensure that `tab.safeId()` has\n          // updated with the final ID value.\n          self.$nextTick(() => {\n            requestAF(() => {\n              self.updateTabs()\n            })\n          })\n        }\n        // Watch for changes to <b-tab> sub components\n        this._bvObserver = observeDom(this.$refs.tabsContainer, handler, {\n          childList: true,\n          subtree: false,\n          attributes: true,\n          attributeFilter: ['id']\n        })\n      } else {\n        if (this._bvObserver && this._bvObserver.disconnect) {\n          this._bvObserver.disconnect()\n        }\n        this._bvObserver = null\n      }\n    },\n    getTabs() {\n      // We use registeredTabs as the source of truth for child tab components. And we\n      // filter out any BTab components that are extended BTab with a root child BTab.\n      // https://github.com/bootstrap-vue/bootstrap-vue/issues/3260\n      const tabs = this.registeredTabs.filter(\n        tab => tab.$children.filter(t => t._isTab).length === 0\n      )\n      // DOM Order of Tabs\n      let order = []\n      if (this.isMounted && tabs.length > 0) {\n        // We rely on the DOM when mounted to get the 'true' order of the b-tab children.\n        // querySelectorAll(...) always returns elements in document order, regardless of\n        // order specified in the selector.\n        const selector = tabs.map(tab => `#${tab.safeId()}`).join(', ')\n        order = selectAll(selector, this.$el)\n          .map(el => el.id)\n          .filter(identity)\n      }\n      // Stable sort keeps the original order if not found in the\n      // `order` array, which will be an empty array before mount.\n      return stableSort(tabs, (a, b) => {\n        return order.indexOf(a.safeId()) - order.indexOf(b.safeId())\n      })\n    },\n    // Update list of <b-tab> children\n    updateTabs() {\n      // Probe tabs\n      const tabs = this.getTabs()\n\n      // Find *last* active non-disabled tab in current tabs\n      // We trust tab state over currentTab, in case tabs were added/removed/re-ordered\n      let tabIndex = tabs.indexOf(\n        tabs\n          .slice()\n          .reverse()\n          .find(tab => tab.localActive && !tab.disabled)\n      )\n\n      // Else try setting to currentTab\n      if (tabIndex < 0) {\n        const currentTab = this.currentTab\n        if (currentTab >= tabs.length) {\n          // Handle last tab being removed, so find the last non-disabled tab\n          tabIndex = tabs.indexOf(\n            tabs\n              .slice()\n              .reverse()\n              .find(notDisabled)\n          )\n        } else if (tabs[currentTab] && !tabs[currentTab].disabled) {\n          // Current tab is not disabled\n          tabIndex = currentTab\n        }\n      }\n\n      // Else find *first* non-disabled tab in current tabs\n      if (tabIndex < 0) {\n        tabIndex = tabs.indexOf(tabs.find(notDisabled))\n      }\n\n      // Set the current tab state to active\n      tabs.forEach(tab => {\n        // tab.localActive = idx === tabIndex && !tab.disabled\n        tab.localActive = false\n      })\n      if (tabs[tabIndex]) {\n        tabs[tabIndex].localActive = true\n      }\n\n      // Update the array of tab children\n      this.tabs = tabs\n      // Set the currentTab index (can be -1 if no non-disabled tabs)\n      this.currentTab = tabIndex\n    },\n    // Find a button that controls a tab, given the tab reference\n    // Returns the button vm instance\n    getButtonForTab(tab) {\n      return (this.$refs.buttons || []).find(btn => btn.tab === tab)\n    },\n    // Force a button to re-render its content, given a <b-tab> instance\n    // Called by <b-tab> on `update()`\n    updateButton(tab) {\n      const button = this.getButtonForTab(tab)\n      if (button && button.$forceUpdate) {\n        button.$forceUpdate()\n      }\n    },\n    // Activate a tab given a <b-tab> instance\n    // Also accessed by <b-tab>\n    activateTab(tab) {\n      let result = false\n      if (tab) {\n        const index = this.tabs.indexOf(tab)\n        if (!tab.disabled && index > -1 && index !== this.currentTab) {\n          const tabEvt = new BvEvent('activate-tab', {\n            cancelable: true,\n            vueTarget: this,\n            componentId: this.safeId()\n          })\n          this.$emit(tabEvt.type, index, this.currentTab, tabEvt)\n          if (!tabEvt.defaultPrevented) {\n            result = true\n            this.currentTab = index\n          }\n        }\n      }\n      // Couldn't set tab, so ensure v-model is set to `this.currentTab`\n      /* istanbul ignore next: should rarely happen */\n      if (!result && this.currentTab !== this.value) {\n        this.$emit('input', this.currentTab)\n      }\n      return result\n    },\n    // Deactivate a tab given a <b-tab> instance\n    // Accessed by <b-tab>\n    deactivateTab(tab) {\n      if (tab) {\n        // Find first non-disabled tab that isn't the one being deactivated\n        // If no tabs are available, then don't deactivate current tab\n        return this.activateTab(this.tabs.filter(t => t !== tab).find(notDisabled))\n      }\n      /* istanbul ignore next: should never/rarely happen */\n      return false\n    },\n    // Focus a tab button given its <b-tab> instance\n    focusButton(tab) {\n      // Wrap in `$nextTick()` to ensure DOM has completed rendering/updating before focusing\n      this.$nextTick(() => {\n        const button = this.getButtonForTab(tab)\n        if (button && button.focus) {\n          button.focus()\n        }\n      })\n    },\n    // Emit a click event on a specified <b-tab> component instance\n    emitTabClick(tab, evt) {\n      if (isEvent(evt) && tab && tab.$emit && !tab.disabled) {\n        tab.$emit('click', evt)\n      }\n    },\n    // Click handler\n    clickTab(tab, evt) {\n      this.activateTab(tab)\n      this.emitTabClick(tab, evt)\n    },\n    // Move to first non-disabled tab\n    firstTab(focus) {\n      const tab = this.tabs.find(notDisabled)\n      if (this.activateTab(tab) && focus) {\n        this.focusButton(tab)\n        this.emitTabClick(tab, focus)\n      }\n    },\n    // Move to previous non-disabled tab\n    previousTab(focus) {\n      const currentIndex = Math.max(this.currentTab, 0)\n      const tab = this.tabs\n        .slice(0, currentIndex)\n        .reverse()\n        .find(notDisabled)\n      if (this.activateTab(tab) && focus) {\n        this.focusButton(tab)\n        this.emitTabClick(tab, focus)\n      }\n    },\n    // Move to next non-disabled tab\n    nextTab(focus) {\n      const currentIndex = Math.max(this.currentTab, -1)\n      const tab = this.tabs.slice(currentIndex + 1).find(notDisabled)\n      if (this.activateTab(tab) && focus) {\n        this.focusButton(tab)\n        this.emitTabClick(tab, focus)\n      }\n    },\n    // Move to last non-disabled tab\n    lastTab(focus) {\n      const tab = this.tabs\n        .slice()\n        .reverse()\n        .find(notDisabled)\n      if (this.activateTab(tab) && focus) {\n        this.focusButton(tab)\n        this.emitTabClick(tab, focus)\n      }\n    }\n  },\n  render(h) {\n    const tabs = this.tabs\n\n    // Currently active tab\n    const activeTab = tabs.find(tab => tab.localActive && !tab.disabled)\n\n    // Tab button to allow focusing when no active tab found (keynav only)\n    const fallbackTab = tabs.find(tab => !tab.disabled)\n\n    // For each <b-tab> found create the tab buttons\n    const buttons = tabs.map((tab, index) => {\n      let tabIndex = null\n      // Ensure at least one tab button is focusable when keynav enabled (if possible)\n      if (!this.noKeyNav) {\n        // Buttons are not in tab index unless active, or a fallback tab\n        tabIndex = -1\n        if (activeTab === tab || (!activeTab && fallbackTab === tab)) {\n          // Place tab button in tab sequence\n          tabIndex = null\n        }\n      }\n      return h(BTabButtonHelper, {\n        key: tab._uid || index,\n        ref: 'buttons',\n        // Needed to make `this.$refs.buttons` an array\n        refInFor: true,\n        props: {\n          tab: tab,\n          tabs: tabs,\n          id: tab.controlledBy || (tab.safeId ? tab.safeId(`_BV_tab_button_`) : null),\n          controls: tab.safeId ? tab.safeId() : null,\n          tabIndex,\n          setSize: tabs.length,\n          posInSet: index + 1,\n          noKeyNav: this.noKeyNav\n        },\n        on: {\n          click: evt => {\n            this.clickTab(tab, evt)\n          },\n          first: this.firstTab,\n          prev: this.previousTab,\n          next: this.nextTab,\n          last: this.lastTab\n        }\n      })\n    })\n\n    // Nav\n    let nav = h(\n      BNav,\n      {\n        ref: 'nav',\n        class: this.localNavClass,\n        attrs: {\n          role: 'tablist',\n          id: this.safeId('_BV_tab_controls_')\n        },\n        props: {\n          fill: this.fill,\n          justified: this.justified,\n          align: this.align,\n          tabs: !this.noNavStyle && !this.pills,\n          pills: !this.noNavStyle && this.pills,\n          vertical: this.vertical,\n          small: this.small,\n          cardHeader: this.card && !this.vertical\n        }\n      },\n      [this.normalizeSlot('tabs-start') || h(), buttons, this.normalizeSlot('tabs-end') || h()]\n    )\n    nav = h(\n      'div',\n      {\n        key: 'bv-tabs-nav',\n        class: [\n          {\n            'card-header': this.card && !this.vertical && !this.end,\n            'card-footer': this.card && !this.vertical && this.end,\n            'col-auto': this.vertical\n          },\n          this.navWrapperClass\n        ]\n      },\n      [nav]\n    )\n\n    let empty = h()\n    if (!tabs || tabs.length === 0) {\n      empty = h(\n        'div',\n        { key: 'bv-empty-tab', class: ['tab-pane', 'active', { 'card-body': this.card }] },\n        this.normalizeSlot('empty')\n      )\n    }\n\n    // Main content section\n    const content = h(\n      'div',\n      {\n        ref: 'tabsContainer',\n        key: 'bv-tabs-container',\n        staticClass: 'tab-content',\n        class: [{ col: this.vertical }, this.contentClass],\n        attrs: { id: this.safeId('_BV_tab_container_') }\n      },\n      concat(this.normalizeSlot('default'), empty)\n    )\n\n    // Render final output\n    return h(\n      this.tag,\n      {\n        staticClass: 'tabs',\n        class: {\n          row: this.vertical,\n          'no-gutters': this.vertical && this.card\n        },\n        attrs: { id: this.safeId() }\n      },\n      [this.end ? content : h(), [nav], this.end ? h() : content]\n    )\n  }\n})\n","import Vue from '../../utils/vue'\nimport idMixin from '../../mixins/id'\nimport normalizeSlotMixin from '../../mixins/normalize-slot'\nimport BVTransition from '../../utils/bv-transition'\n\n// @vue/component\nexport const BTab = /*#__PURE__*/ Vue.extend({\n  name: 'BTab',\n  mixins: [idMixin, normalizeSlotMixin],\n  inject: {\n    bvTabs: {\n      default: () => ({})\n    }\n  },\n  props: {\n    active: {\n      type: Boolean,\n      default: false\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    buttonId: {\n      type: String,\n      default: ''\n    },\n    title: {\n      type: String,\n      default: ''\n    },\n    titleItemClass: {\n      // Sniffed by tabs.js and added to nav 'li.nav-item'\n      type: [String, Array, Object],\n      default: null\n    },\n    titleLinkClass: {\n      // Sniffed by tabs.js and added to nav 'a.nav-link'\n      type: [String, Array, Object],\n      default: null\n    },\n    titleLinkAttributes: {\n      type: Object,\n      default: null\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    noBody: {\n      type: Boolean,\n      default: false\n    },\n    lazy: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data() {\n    return {\n      localActive: this.active && !this.disabled,\n      show: false\n    }\n  },\n  computed: {\n    tabClasses() {\n      return [\n        {\n          active: this.localActive,\n          disabled: this.disabled,\n          'card-body': this.bvTabs.card && !this.noBody\n        },\n        // Apply <b-tabs> `activeTabClass` styles when this tab is active\n        this.localActive ? this.bvTabs.activeTabClass : null\n      ]\n    },\n    controlledBy() {\n      return this.buttonId || this.safeId('__BV_tab_button__')\n    },\n    computedNoFade() {\n      return !(this.bvTabs.fade || false)\n    },\n    computedLazy() {\n      return this.bvTabs.lazy || this.lazy\n    },\n    _isTab() {\n      // For parent sniffing of child\n      return true\n    }\n  },\n  watch: {\n    localActive(newVal) {\n      // Make 'active' prop work with `.sync` modifier\n      this.$emit('update:active', newVal)\n    },\n    active(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        if (newVal) {\n          // If activated post mount\n          this.activate()\n        } else {\n          /* istanbul ignore next */\n          if (!this.deactivate()) {\n            // Tab couldn't be deactivated, so we reset the synced active prop\n            // Deactivation will fail if no other tabs to activate\n            this.$emit('update:active', this.localActive)\n          }\n        }\n      }\n    },\n    disabled(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        if (newVal && this.localActive && this.bvTabs.firstTab) {\n          this.localActive = false\n          this.bvTabs.firstTab()\n        }\n      }\n    }\n  },\n  mounted() {\n    // Inform b-tabs of our presence\n    this.registerTab()\n    // Initially show on mount if active and not disabled\n    this.show = this.localActive\n  },\n  updated() {\n    // Force the tab button content to update (since slots are not reactive)\n    // Only done if we have a title slot, as the title prop is reactive\n    if (this.hasNormalizedSlot('title') && this.bvTabs.updateButton) {\n      this.bvTabs.updateButton(this)\n    }\n  },\n  destroyed() {\n    // inform b-tabs of our departure\n    this.unregisterTab()\n  },\n  methods: {\n    // Private methods\n    registerTab() {\n      // Inform `b-tabs` of our presence\n      this.bvTabs.registerTab && this.bvTabs.registerTab(this)\n    },\n    unregisterTab() {\n      // Inform `b-tabs` of our departure\n      this.bvTabs.unregisterTab && this.bvTabs.unregisterTab(this)\n    },\n    // Public methods\n    activate() {\n      if (this.bvTabs.activateTab && !this.disabled) {\n        return this.bvTabs.activateTab(this)\n      } else {\n        // Not inside a <b-tabs> component or tab is disabled\n        return false\n      }\n    },\n    deactivate() {\n      if (this.bvTabs.deactivateTab && this.localActive) {\n        return this.bvTabs.deactivateTab(this)\n      } else {\n        // Not inside a <b-tabs> component or not active to begin with\n        return false\n      }\n    }\n  },\n  render(h) {\n    const content = h(\n      this.tag,\n      {\n        ref: 'panel',\n        staticClass: 'tab-pane',\n        class: this.tabClasses,\n        directives: [\n          {\n            name: 'show',\n            rawName: 'v-show',\n            value: this.localActive,\n            expression: 'localActive'\n          }\n        ],\n        attrs: {\n          role: 'tabpanel',\n          id: this.safeId(),\n          'aria-hidden': this.localActive ? 'false' : 'true',\n          'aria-labelledby': this.controlledBy || null\n        }\n      },\n      // Render content lazily if requested\n      [this.localActive || !this.computedLazy ? this.normalizeSlot('default') : h()]\n    )\n    return h(BVTransition, { props: { mode: 'out-in', noFade: this.computedNoFade } }, [content])\n  }\n})\n","import { BTabs } from './tabs'\nimport { BTab } from './tab'\nimport { pluginFactory } from '../../utils/plugins'\n\nconst TabsPlugin = /*#__PURE__*/ pluginFactory({\n  components: {\n    BTabs,\n    BTab\n  }\n})\n\nexport { TabsPlugin, BTabs, BTab }\n","/*\n * ScrollSpy class definition\n */\n\nimport observeDom from '../../utils/observe-dom'\nimport {\n  addClass,\n  closest,\n  getAttr,\n  getBCR,\n  hasClass,\n  isElement,\n  isVisible,\n  matches,\n  offset,\n  position,\n  removeClass,\n  select,\n  selectAll\n} from '../../utils/dom'\nimport { EVENT_OPTIONS_NO_CAPTURE, eventOn, eventOff } from '../../utils/events'\nimport { isString, isUndefined } from '../../utils/inspect'\nimport { toString as objectToString } from '../../utils/object'\nimport { warn } from '../../utils/warn'\n\n/*\n * Constants / Defaults\n */\n\nconst NAME = 'v-b-scrollspy'\nconst ACTIVATE_EVENT = 'bv::scrollspy::activate'\n\nconst Default = {\n  element: 'body',\n  offset: 10,\n  method: 'auto',\n  throttle: 75\n}\n\nconst DefaultType = {\n  element: '(string|element|component)',\n  offset: 'number',\n  method: 'string',\n  throttle: 'number'\n}\n\nconst ClassName = {\n  DROPDOWN_ITEM: 'dropdown-item',\n  ACTIVE: 'active'\n}\n\nconst Selector = {\n  ACTIVE: '.active',\n  NAV_LIST_GROUP: '.nav, .list-group',\n  NAV_LINKS: '.nav-link',\n  NAV_ITEMS: '.nav-item',\n  LIST_ITEMS: '.list-group-item',\n  DROPDOWN: '.dropdown, .dropup',\n  DROPDOWN_ITEMS: '.dropdown-item',\n  DROPDOWN_TOGGLE: '.dropdown-toggle'\n}\n\nconst OffsetMethod = {\n  OFFSET: 'offset',\n  POSITION: 'position'\n}\n\n// HREFs must end with a hash followed by at least one non-hash character.\n// HREFs in the links are assumed to point to non-external links.\n// Comparison to the current page base URL is not performed!\nconst HREF_REGEX = /^.*(#[^#]+)$/\n\n// Transition Events\nconst TransitionEndEvents = [\n  'webkitTransitionEnd',\n  'transitionend',\n  'otransitionend',\n  'oTransitionEnd'\n]\n\n/*\n * Utility Methods\n */\n\n// Better var type detection\nconst toType = obj => /* istanbul ignore next: not easy to test */ {\n  return objectToString(obj)\n    .match(/\\s([a-zA-Z]+)/)[1]\n    .toLowerCase()\n}\n\n// Check config properties for expected types\nconst typeCheckConfig = (\n  componentName,\n  config,\n  configTypes\n) => /* istanbul ignore next: not easy to test */ {\n  for (const property in configTypes) {\n    if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n      const expectedTypes = configTypes[property]\n      const value = config[property]\n      let valueType = value && isElement(value) ? 'element' : toType(value)\n      // handle Vue instances\n      valueType = value && value._isVue ? 'component' : valueType\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        /* istanbul ignore next */\n        warn(\n          `${componentName}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\"`\n        )\n      }\n    }\n  }\n}\n\n/*\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\n/* istanbul ignore next: not easy to test */\nclass ScrollSpy /* istanbul ignore next: not easy to test */ {\n  constructor(element, config, $root) {\n    // The element we activate links in\n    this.$el = element\n    this.$scroller = null\n    this.$selector = [Selector.NAV_LINKS, Selector.LIST_ITEMS, Selector.DROPDOWN_ITEMS].join(',')\n    this.$offsets = []\n    this.$targets = []\n    this.$activeTarget = null\n    this.$scrollHeight = 0\n    this.$resizeTimeout = null\n    this.$obs_scroller = null\n    this.$obs_targets = null\n    this.$root = $root || null\n    this.$config = null\n\n    this.updateConfig(config)\n  }\n\n  static get Name() {\n    return NAME\n  }\n\n  static get Default() {\n    return Default\n  }\n\n  static get DefaultType() {\n    return DefaultType\n  }\n\n  updateConfig(config, $root) {\n    if (this.$scroller) {\n      // Just in case out scroll element has changed\n      this.unlisten()\n      this.$scroller = null\n    }\n    const cfg = { ...this.constructor.Default, ...config }\n    if ($root) {\n      this.$root = $root\n    }\n    typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType)\n    this.$config = cfg\n\n    if (this.$root) {\n      const self = this\n      this.$root.$nextTick(() => {\n        self.listen()\n      })\n    } else {\n      this.listen()\n    }\n  }\n\n  dispose() {\n    this.unlisten()\n    clearTimeout(this.$resizeTimeout)\n    this.$resizeTimeout = null\n    this.$el = null\n    this.$config = null\n    this.$scroller = null\n    this.$selector = null\n    this.$offsets = null\n    this.$targets = null\n    this.$activeTarget = null\n    this.$scrollHeight = null\n  }\n\n  listen() {\n    const scroller = this.getScroller()\n    if (scroller && scroller.tagName !== 'BODY') {\n      eventOn(scroller, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE)\n    }\n    eventOn(window, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE)\n    eventOn(window, 'resize', this, EVENT_OPTIONS_NO_CAPTURE)\n    eventOn(window, 'orientationchange', this, EVENT_OPTIONS_NO_CAPTURE)\n    TransitionEndEvents.forEach(evtName => {\n      eventOn(window, evtName, this, EVENT_OPTIONS_NO_CAPTURE)\n    })\n    this.setObservers(true)\n    // Schedule a refresh\n    this.handleEvent('refresh')\n  }\n\n  unlisten() {\n    const scroller = this.getScroller()\n    this.setObservers(false)\n    if (scroller && scroller.tagName !== 'BODY') {\n      eventOff(scroller, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE)\n    }\n    eventOff(window, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE)\n    eventOff(window, 'resize', this, EVENT_OPTIONS_NO_CAPTURE)\n    eventOff(window, 'orientationchange', this, EVENT_OPTIONS_NO_CAPTURE)\n    TransitionEndEvents.forEach(evtName => {\n      eventOff(window, evtName, this, EVENT_OPTIONS_NO_CAPTURE)\n    })\n  }\n\n  setObservers(on) {\n    // We observe both the scroller for content changes, and the target links\n    if (this.$obs_scroller) {\n      this.$obs_scroller.disconnect()\n      this.$obs_scroller = null\n    }\n    if (this.$obs_targets) {\n      this.$obs_targets.disconnect()\n      this.$obs_targets = null\n    }\n    if (on) {\n      this.$obs_targets = observeDom(\n        this.$el,\n        () => {\n          this.handleEvent('mutation')\n        },\n        {\n          subtree: true,\n          childList: true,\n          attributes: true,\n          attributeFilter: ['href']\n        }\n      )\n      this.$obs_scroller = observeDom(\n        this.getScroller(),\n        () => {\n          this.handleEvent('mutation')\n        },\n        {\n          subtree: true,\n          childList: true,\n          characterData: true,\n          attributes: true,\n          attributeFilter: ['id', 'style', 'class']\n        }\n      )\n    }\n  }\n\n  // General event handler\n  handleEvent(evt) {\n    const type = isString(evt) ? evt : evt.type\n\n    const self = this\n    const resizeThrottle = () => {\n      if (!self.$resizeTimeout) {\n        self.$resizeTimeout = setTimeout(() => {\n          self.refresh()\n          self.process()\n          self.$resizeTimeout = null\n        }, self.$config.throttle)\n      }\n    }\n\n    if (type === 'scroll') {\n      if (!this.$obs_scroller) {\n        // Just in case we are added to the DOM before the scroll target is\n        // We re-instantiate our listeners, just in case\n        this.listen()\n      }\n      this.process()\n    } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {\n      // Postpone these events by throttle time\n      resizeThrottle()\n    }\n  }\n\n  // Refresh the list of target links on the element we are applied to\n  refresh() {\n    const scroller = this.getScroller()\n    if (!scroller) {\n      return\n    }\n    const autoMethod = scroller !== scroller.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET\n    const method = this.$config.method === 'auto' ? autoMethod : this.$config.method\n    const methodFn = method === OffsetMethod.POSITION ? position : offset\n    const offsetBase = method === OffsetMethod.POSITION ? this.getScrollTop() : 0\n\n    this.$offsets = []\n    this.$targets = []\n\n    this.$scrollHeight = this.getScrollHeight()\n\n    // Find all the unique link HREFs that we will control\n    selectAll(this.$selector, this.$el)\n      // Get HREF value\n      .map(link => getAttr(link, 'href'))\n      // Filter out HREFs that do not match our RegExp\n      .filter(href => href && HREF_REGEX.test(href || ''))\n      // Find all elements with ID that match HREF hash\n      .map(href => {\n        // Convert HREF into an ID (including # at beginning)\n        const id = href.replace(HREF_REGEX, '$1').trim()\n        if (!id) {\n          return null\n        }\n        // Find the element with the ID specified by id\n        const el = select(id, scroller)\n        if (el && isVisible(el)) {\n          return {\n            offset: parseInt(methodFn(el).top, 10) + offsetBase,\n            target: id\n          }\n        }\n        return null\n      })\n      .filter(Boolean)\n      // Sort them by their offsets (smallest first)\n      .sort((a, b) => a.offset - b.offset)\n      // record only unique targets/offsets\n      .reduce((memo, item) => {\n        if (!memo[item.target]) {\n          this.$offsets.push(item.offset)\n          this.$targets.push(item.target)\n          memo[item.target] = true\n        }\n        return memo\n      }, {})\n\n    // Return this for easy chaining\n    return this\n  }\n\n  // Handle activating/clearing\n  process() {\n    const scrollTop = this.getScrollTop() + this.$config.offset\n    const scrollHeight = this.getScrollHeight()\n    const maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight()\n\n    if (this.$scrollHeight !== scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      const target = this.$targets[this.$targets.length - 1]\n      if (this.$activeTarget !== target) {\n        this.activate(target)\n      }\n      return\n    }\n\n    if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {\n      this.$activeTarget = null\n      this.clear()\n      return\n    }\n\n    for (let i = this.$offsets.length; i--; ) {\n      const isActiveTarget =\n        this.$activeTarget !== this.$targets[i] &&\n        scrollTop >= this.$offsets[i] &&\n        (isUndefined(this.$offsets[i + 1]) || scrollTop < this.$offsets[i + 1])\n\n      if (isActiveTarget) {\n        this.activate(this.$targets[i])\n      }\n    }\n  }\n\n  getScroller() {\n    if (this.$scroller) {\n      return this.$scroller\n    }\n    let scroller = this.$config.element\n    if (!scroller) {\n      return null\n    } else if (isElement(scroller.$el)) {\n      scroller = scroller.$el\n    } else if (isString(scroller)) {\n      scroller = select(scroller)\n    }\n    if (!scroller) {\n      return null\n    }\n    this.$scroller = scroller.tagName === 'BODY' ? window : scroller\n    return this.$scroller\n  }\n\n  getScrollTop() {\n    const scroller = this.getScroller()\n    return scroller === window ? scroller.pageYOffset : scroller.scrollTop\n  }\n\n  getScrollHeight() {\n    return (\n      this.getScroller().scrollHeight ||\n      Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)\n    )\n  }\n\n  getOffsetHeight() {\n    const scroller = this.getScroller()\n    return scroller === window ? window.innerHeight : getBCR(scroller).height\n  }\n\n  activate(target) {\n    this.$activeTarget = target\n    this.clear()\n\n    // Grab the list of target links (<a href=\"{$target}\">)\n    const links = selectAll(\n      this.$selector\n        // Split out the base selectors\n        .split(',')\n        // Map to a selector that matches links with HREF ending in the ID (including '#')\n        .map(selector => `${selector}[href$=\"${target}\"]`)\n        // Join back into a single selector string\n        .join(','),\n      this.$el\n    )\n\n    links.forEach(link => {\n      if (hasClass(link, ClassName.DROPDOWN_ITEM)) {\n        // This is a dropdown item, so find the .dropdown-toggle and set its state\n        const dropdown = closest(Selector.DROPDOWN, link)\n        if (dropdown) {\n          this.setActiveState(select(Selector.DROPDOWN_TOGGLE, dropdown), true)\n        }\n        // Also set this link's state\n        this.setActiveState(link, true)\n      } else {\n        // Set triggered link as active\n        this.setActiveState(link, true)\n        if (matches(link.parentElement, Selector.NAV_ITEMS)) {\n          // Handle nav-link inside nav-item, and set nav-item active\n          this.setActiveState(link.parentElement, true)\n        }\n        // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n        let el = link\n        while (el) {\n          el = closest(Selector.NAV_LIST_GROUP, el)\n          const sibling = el ? el.previousElementSibling : null\n          if (sibling && matches(sibling, `${Selector.NAV_LINKS}, ${Selector.LIST_ITEMS}`)) {\n            this.setActiveState(sibling, true)\n          }\n          // Handle special case where nav-link is inside a nav-item\n          if (sibling && matches(sibling, Selector.NAV_ITEMS)) {\n            this.setActiveState(select(Selector.NAV_LINKS, sibling), true)\n            // Add active state to nav-item as well\n            this.setActiveState(sibling, true)\n          }\n        }\n      }\n    })\n\n    // Signal event to via $root, passing ID of activated target and reference to array of links\n    if (links && links.length > 0 && this.$root) {\n      this.$root.$emit(ACTIVATE_EVENT, target, links)\n    }\n  }\n\n  clear() {\n    selectAll(`${this.$selector}, ${Selector.NAV_ITEMS}`, this.$el)\n      .filter(el => hasClass(el, ClassName.ACTIVE))\n      .forEach(el => this.setActiveState(el, false))\n  }\n\n  setActiveState(el, active) {\n    if (!el) {\n      return\n    }\n    if (active) {\n      addClass(el, ClassName.ACTIVE)\n    } else {\n      removeClass(el, ClassName.ACTIVE)\n    }\n  }\n}\n\nexport default ScrollSpy\n","import ScrollSpy from './scrollspy.class'\nimport { isBrowser } from '../../utils/env'\nimport { keys } from '../../utils/object'\nimport { isNumber, isObject, isString } from '../../utils/inspect'\n\n// Key we use to store our instance\nconst BV_SCROLLSPY = '__BV_ScrollSpy__'\n\n// Pre-compiled regular expressions\nconst onlyDigitsRE = /^\\d+$/\nconst offsetRE = /^(auto|position|offset)$/\n\n// Build a ScrollSpy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n/* istanbul ignore next: not easy to test */\nconst parseBindings = bindings => /* istanbul ignore next: not easy to test */ {\n  const config = {}\n\n  // If argument, assume element ID\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.element = `#${bindings.arg}`\n  }\n\n  // Process modifiers\n  keys(bindings.modifiers).forEach(mod => {\n    if (onlyDigitsRE.test(mod)) {\n      // Offset value\n      config.offset = parseInt(mod, 10)\n    } else if (offsetRE.test(mod)) {\n      // Offset method\n      config.method = mod\n    }\n  })\n\n  // Process value\n  if (isString(bindings.value)) {\n    // Value is a CSS ID or selector\n    config.element = bindings.value\n  } else if (isNumber(bindings.value)) {\n    // Value is offset\n    config.offset = Math.round(bindings.value)\n  } else if (isObject(bindings.value)) {\n    // Value is config object\n    // Filter the object based on our supported config options\n    keys(bindings.value)\n      .filter(k => !!ScrollSpy.DefaultType[k])\n      .forEach(k => {\n        config[k] = bindings.value[k]\n      })\n  }\n\n  return config\n}\n\n// Add or update ScrollSpy on our element\nconst applyScrollspy = (el, bindings, vnode) => /* istanbul ignore next: not easy to test */ {\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return\n  }\n  const config = parseBindings(bindings)\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root)\n  } else {\n    el[BV_SCROLLSPY] = new ScrollSpy(el, config, vnode.context.$root)\n  }\n}\n\n// Remove ScrollSpy on our element\n/* istanbul ignore next: not easy to test */\nconst removeScrollspy = el => /* istanbul ignore next: not easy to test */ {\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].dispose()\n    el[BV_SCROLLSPY] = null\n    delete el[BV_SCROLLSPY]\n  }\n}\n\n/*\n * Export our directive\n */\nexport const VBScrollspy = {\n  bind(el, bindings, vnode) /* istanbul ignore next: not easy to test */ {\n    applyScrollspy(el, bindings, vnode)\n  },\n  inserted(el, bindings, vnode) /* istanbul ignore next: not easy to test */ {\n    applyScrollspy(el, bindings, vnode)\n  },\n  update(el, bindings, vnode) /* istanbul ignore next: not easy to test */ {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode)\n    }\n  },\n  componentUpdated(el, bindings, vnode) /* istanbul ignore next: not easy to test */ {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode)\n    }\n  },\n  unbind(el) /* istanbul ignore next: not easy to test */ {\n    removeScrollspy(el)\n  }\n}\n","import { VBScrollspy } from './scrollspy'\nimport { pluginFactory } from '../../utils/plugins'\n\nconst VBScrollspyPlugin = /*#__PURE__*/ pluginFactory({\n  directives: { VBScrollspy }\n})\n\nexport { VBScrollspyPlugin, VBScrollspy }\n","import Vue from '../../utils/vue'\nimport { getComponentConfig } from '../../utils/config'\nimport { HTMLElement } from '../../utils/safe-types'\nimport { BTooltip } from '../tooltip/tooltip'\nimport { BVPopover } from './helpers/bv-popover'\n\nconst NAME = 'BPopover'\n\nexport const BPopover = /*#__PURE__*/ Vue.extend({\n  name: NAME,\n  extends: BTooltip,\n  inheritAttrs: false,\n  props: {\n    title: {\n      type: String\n      // default: undefined\n    },\n    content: {\n      type: String\n      // default: undefined\n    },\n    triggers: {\n      type: [String, Array],\n      default: 'click'\n    },\n    placement: {\n      type: String,\n      default: 'right'\n    },\n    variant: {\n      type: String,\n      default: () => getComponentConfig(NAME, 'variant')\n    },\n    customClass: {\n      type: String,\n      default: () => getComponentConfig(NAME, 'customClass')\n    },\n    delay: {\n      type: [Number, Object, String],\n      default: () => getComponentConfig(NAME, 'delay')\n    },\n    boundary: {\n      // String: scrollParent, window, or viewport\n      // Element: element reference\n      // Object: Vue component\n      type: [String, HTMLElement, Object],\n      default: () => getComponentConfig(NAME, 'boundary')\n    },\n    boundaryPadding: {\n      type: [Number, String],\n      default: () => getComponentConfig(NAME, 'boundaryPadding')\n    }\n  },\n  methods: {\n    getComponent() {\n      // Overridden by BPopover\n      return BVPopover\n    },\n    updateContent() {\n      // Tooltip: Default slot is `title`\n      // Popover: Default slot is `content`, `title` slot is title\n      // We pass a scoped slot function references by default (Vue v2.6x)\n      // And pass the title prop as a fallback\n      this.setContent(this.$scopedSlots.default || this.content)\n      this.setTitle(this.$scopedSlots.title || this.title)\n    }\n  }\n  // Render function provided by BTooltip\n})\n","import { BPopover } from './popover'\nimport { VBPopoverPlugin } from '../../directives/popover'\nimport { pluginFactory } from '../../utils/plugins'\n\nconst PopoverPlugin = /*#__PURE__*/ pluginFactory({\n  components: { BPopover },\n  plugins: { VBPopoverPlugin }\n})\n\nexport { PopoverPlugin, BPopover }\n","import getScopId from '../../utils/get-scope-id'\nimport identity from '../../utils/identity'\nimport looseEqual from '../../utils/loose-equal'\nimport { concat } from '../../utils/array'\nimport { getComponentConfig } from '../../utils/config'\nimport { isBrowser } from '../../utils/env'\nimport {\n  isFunction,\n  isNumber,\n  isPlainObject,\n  isString,\n  isUndefined,\n  isUndefinedOrNull\n} from '../../utils/inspect'\nimport { keys } from '../../utils/object'\nimport { BVTooltip } from '../../components/tooltip/helpers/bv-tooltip'\n\n// Key which we use to store tooltip object on element\nconst BV_TOOLTIP = '__BV_Tooltip__'\n\n// Default trigger\nconst DefaultTrigger = 'hover focus'\n\n// Valid event triggers\nconst validTriggers = {\n  focus: true,\n  hover: true,\n  click: true,\n  blur: true,\n  manual: true\n}\n\n// Directive modifier test regular expressions. Pre-compile for performance\nconst htmlRE = /^html$/i\nconst noninteractiveRE = /^noninteractive$/i\nconst noFadeRE = /^nofade$/i\nconst placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i\nconst boundaryRE = /^(window|viewport|scrollParent)$/i\nconst delayRE = /^d\\d+$/i\nconst delayShowRE = /^ds\\d+$/i\nconst delayHideRE = /^dh\\d+$/i\nconst offsetRE = /^o-?\\d+$/i\nconst variantRE = /^v-.+$/i\nconst spacesRE = /\\s+/\n\n// Build a Tooltip config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\nconst parseBindings = (bindings, vnode) => /* istanbul ignore next: not easy to test */ {\n  // We start out with a basic config\n  const NAME = 'BTooltip'\n  // Default config\n  let config = {\n    title: undefined,\n    trigger: '', // Default set below if needed\n    placement: 'top',\n    fallbackPlacement: 'flip',\n    container: false, // Default of body\n    animation: true,\n    offset: 0,\n    id: null,\n    html: false,\n    interactive: true,\n    disabled: false,\n    delay: getComponentConfig(NAME, 'delay'),\n    boundary: String(getComponentConfig(NAME, 'boundary')),\n    boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,\n    variant: getComponentConfig(NAME, 'variant'),\n    customClass: getComponentConfig(NAME, 'customClass')\n  }\n\n  // Process `bindings.value`\n  if (isString(bindings.value) || isNumber(bindings.value)) {\n    // Value is tooltip content (HTML optionally supported)\n    config.title = bindings.value\n  } else if (isFunction(bindings.value)) {\n    // Title generator function\n    config.title = bindings.value\n  } else if (isPlainObject(bindings.value)) {\n    // Value is config object, so merge\n    config = { ...config, ...bindings.value }\n  }\n\n  // If title is not provided, try title attribute\n  if (isUndefined(config.title)) {\n    // Try attribute\n    const data = vnode.data || {}\n    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined\n  }\n\n  // Normalize delay\n  if (!isPlainObject(config.delay)) {\n    config.delay = {\n      show: parseInt(config.delay, 10) || 0,\n      hide: parseInt(config.delay, 10) || 0\n    }\n  }\n\n  // If argument, assume element ID of container element\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.container = `#${bindings.arg}`\n  }\n\n  // Process modifiers\n  keys(bindings.modifiers).forEach(mod => {\n    if (htmlRE.test(mod)) {\n      // Title allows HTML\n      config.html = true\n    } else if (noninteractiveRE.test(mod)) {\n      // Noninteractive\n      config.interactive = false\n    } else if (noFadeRE.test(mod)) {\n      // No animation\n      config.animation = false\n    } else if (placementRE.test(mod)) {\n      // Placement of tooltip\n      config.placement = mod\n    } else if (boundaryRE.test(mod)) {\n      // Boundary of tooltip\n      mod = mod === 'scrollparent' ? 'scrollParent' : mod\n      config.boundary = mod\n    } else if (delayRE.test(mod)) {\n      // Delay value\n      const delay = parseInt(mod.slice(1), 10) || 0\n      config.delay.show = delay\n      config.delay.hide = delay\n    } else if (delayShowRE.test(mod)) {\n      // Delay show value\n      config.delay.show = parseInt(mod.slice(2), 10) || 0\n    } else if (delayHideRE.test(mod)) {\n      // Delay hide value\n      config.delay.hide = parseInt(mod.slice(2), 10) || 0\n    } else if (offsetRE.test(mod)) {\n      // Offset value, negative allowed\n      config.offset = parseInt(mod.slice(1), 10) || 0\n    } else if (variantRE.test(mod)) {\n      // Variant\n      config.variant = mod.slice(2) || null\n    }\n  })\n\n  // Special handling of event trigger modifiers trigger is\n  // a space separated list\n  const selectedTriggers = {}\n\n  // Parse current config object trigger\n  concat(config.trigger || '')\n    .filter(identity)\n    .join(' ')\n    .trim()\n    .toLowerCase()\n    .split(spacesRE)\n    .forEach(trigger => {\n      if (validTriggers[trigger]) {\n        selectedTriggers[trigger] = true\n      }\n    })\n\n  // Parse modifiers for triggers\n  keys(bindings.modifiers).forEach(mod => {\n    mod = mod.toLowerCase()\n    if (validTriggers[mod]) {\n      // If modifier is a valid trigger\n      selectedTriggers[mod] = true\n    }\n  })\n\n  // Sanitize triggers\n  config.trigger = keys(selectedTriggers).join(' ')\n  if (config.trigger === 'blur') {\n    // Blur by itself is useless, so convert it to 'focus'\n    config.trigger = 'focus'\n  }\n  if (!config.trigger) {\n    // Use default trigger\n    config.trigger = DefaultTrigger\n  }\n\n  // Return the config\n  return config\n}\n\n// Add/update Tooltip on our element\nconst applyTooltip = (el, bindings, vnode) => {\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return\n  }\n  const config = parseBindings(bindings, vnode)\n  if (!el[BV_TOOLTIP]) {\n    const $parent = vnode.context\n    el[BV_TOOLTIP] = new BVTooltip({\n      parent: $parent,\n      // Add the parent's scoped style attribute data\n      _scopeId: getScopId($parent, undefined)\n    })\n    el[BV_TOOLTIP].__bv_prev_data__ = {}\n    el[BV_TOOLTIP].$on('show', () => /* istanbul ignore next: for now */ {\n      // Before showing the tooltip, we update the title if it is a function\n      if (isFunction(config.title)) {\n        el[BV_TOOLTIP].updateData({\n          title: config.title(el)\n        })\n      }\n    })\n  }\n  const data = {\n    title: config.title,\n    triggers: config.trigger,\n    placement: config.placement,\n    fallbackPlacement: config.fallbackPlacement,\n    variant: config.variant,\n    customClass: config.customClass,\n    container: config.container,\n    boundary: config.boundary,\n    delay: config.delay,\n    offset: config.offset,\n    noFade: !config.animation,\n    id: config.id,\n    interactive: config.interactive,\n    disabled: config.disabled,\n    html: config.html\n  }\n  const oldData = el[BV_TOOLTIP].__bv_prev_data__\n  el[BV_TOOLTIP].__bv_prev_data__ = data\n  if (!looseEqual(data, oldData)) {\n    // We only update the instance if data has changed\n    const newData = {\n      target: el\n    }\n    keys(data).forEach(prop => {\n      // We only pass data properties that have changed\n      if (data[prop] !== oldData[prop]) {\n        // if title is a function, we execute it here\n        newData[prop] = prop === 'title' && isFunction(data[prop]) ? data[prop](el) : data[prop]\n      }\n    })\n    el[BV_TOOLTIP].updateData(newData)\n  }\n}\n\n// Remove Tooltip on our element\nconst removeTooltip = el => {\n  if (el[BV_TOOLTIP]) {\n    el[BV_TOOLTIP].$destroy()\n    el[BV_TOOLTIP] = null\n  }\n  delete el[BV_TOOLTIP]\n}\n\n// Export our directive\nexport const VBTooltip = {\n  bind(el, bindings, vnode) {\n    applyTooltip(el, bindings, vnode)\n  },\n  // We use `componentUpdated` here instead of `update`, as the former\n  // waits until the containing component and children have finished updating\n  componentUpdated(el, bindings, vnode) {\n    // Performed in a `$nextTick()` to prevent render update loops\n    vnode.context.$nextTick(() => {\n      applyTooltip(el, bindings, vnode)\n    })\n  },\n  unbind(el) {\n    removeTooltip(el)\n  }\n}\n","import { VBTooltip } from './tooltip'\nimport { pluginFactory } from '../../utils/plugins'\n\nconst VBTooltipPlugin = /*#__PURE__*/ pluginFactory({\n  directives: { VBTooltip }\n})\n\nexport { VBTooltipPlugin, VBTooltip }\n","import looseEqual from '../../utils/loose-equal'\nimport { addClass, hasAttr, removeAttr, removeClass, setAttr } from '../../utils/dom'\nimport { isBrowser } from '../../utils/env'\nimport { bindTargets, getTargets, unbindTargets } from '../../utils/target'\n\n// Target listen types\nconst listenTypes = { click: true }\n\n// Property key for handler storage\nconst BV_TOGGLE = '__BV_toggle__'\nconst BV_TOGGLE_STATE = '__BV_toggle_STATE__'\nconst BV_TOGGLE_CONTROLS = '__BV_toggle_CONTROLS__'\nconst BV_TOGGLE_TARGETS = '__BV_toggle_TARGETS__'\n\n// Emitted control event for collapse (emitted to collapse)\nexport const EVENT_TOGGLE = 'bv::toggle::collapse'\n\n// Listen to event for toggle state update (emitted by collapse)\nexport const EVENT_STATE = 'bv::collapse::state'\n\n// Private event emitted on `$root` to ensure the toggle state is always synced\n// Gets emitted even if the state of b-collapse has not changed\n// This event is NOT to be documented as people should not be using it\nexport const EVENT_STATE_SYNC = 'bv::collapse::sync::state'\n// Private event we send to collapse to request state update sync event\nexport const EVENT_STATE_REQUEST = 'bv::request::collapse::state'\n\n// Reset and remove a property from the provided element\nconst resetProp = (el, prop) => {\n  el[prop] = null\n  delete el[prop]\n}\n\n// Handle targets update\nconst handleTargets = ({ targets, vnode }) => {\n  targets.forEach(target => {\n    vnode.context.$root.$emit(EVENT_TOGGLE, target)\n  })\n}\n\n// Handle directive updates\n/* istanbul ignore next: not easy to test */\nconst handleUpdate = (el, binding, vnode) => {\n  if (!isBrowser) {\n    return\n  }\n\n  if (!looseEqual(getTargets(binding), el[BV_TOGGLE_TARGETS])) {\n    // Targets have changed, so update accordingly\n    unbindTargets(vnode, binding, listenTypes)\n    const targets = bindTargets(vnode, binding, listenTypes, handleTargets)\n    // Update targets array to element\n    el[BV_TOGGLE_TARGETS] = targets\n    // Add aria attributes to element\n    el[BV_TOGGLE_CONTROLS] = targets.join(' ')\n    // ensure aria-controls is up to date\n    setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS])\n    // Request a state update from targets so that we can ensure\n    // expanded state is correct\n    targets.forEach(target => {\n      vnode.context.$root.$emit(EVENT_STATE_REQUEST, target)\n    })\n  }\n\n  // Ensure the collapse class and aria-* attributes persist\n  // after element is updated (either by parent re-rendering\n  // or changes to this element or its contents\n  if (el[BV_TOGGLE_STATE] === true) {\n    addClass(el, 'collapsed')\n    setAttr(el, 'aria-expanded', 'true')\n  } else if (el[BV_TOGGLE_STATE] === false) {\n    removeClass(el, 'collapsed')\n    setAttr(el, 'aria-expanded', 'false')\n  }\n  setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS])\n}\n\n/*\n * Export our directive\n */\nexport const VBToggle = {\n  bind(el, binding, vnode) {\n    const targets = bindTargets(vnode, binding, listenTypes, handleTargets)\n    if (isBrowser && vnode.context && targets.length > 0) {\n      // Add targets array to element\n      el[BV_TOGGLE_TARGETS] = targets\n      // Add aria attributes to element\n      el[BV_TOGGLE_CONTROLS] = targets.join(' ')\n      // State is initially collapsed until we receive a state event\n      el[BV_TOGGLE_STATE] = false\n      setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS])\n      setAttr(el, 'aria-expanded', 'false')\n      // If element is not a button, we add `role=\"button\"` for accessibility\n      if (el.tagName !== 'BUTTON' && !hasAttr(el, 'role')) {\n        setAttr(el, 'role', 'button')\n      }\n\n      // Toggle state handler\n      const toggleDirectiveHandler = (id, state) => {\n        const targets = el[BV_TOGGLE_TARGETS] || []\n        if (targets.indexOf(id) !== -1) {\n          // Set aria-expanded state\n          setAttr(el, 'aria-expanded', state ? 'true' : 'false')\n          // Set/Clear 'collapsed' class state\n          el[BV_TOGGLE_STATE] = state\n          if (state) {\n            removeClass(el, 'collapsed')\n          } else {\n            addClass(el, 'collapsed')\n          }\n        }\n      }\n\n      // Store the toggle handler on the element\n      el[BV_TOGGLE] = toggleDirectiveHandler\n\n      // Listen for toggle state changes (public)\n      vnode.context.$root.$on(EVENT_STATE, el[BV_TOGGLE])\n      // Listen for toggle state sync (private)\n      vnode.context.$root.$on(EVENT_STATE_SYNC, el[BV_TOGGLE])\n    }\n  },\n  componentUpdated: handleUpdate,\n  updated: handleUpdate,\n  unbind(el, binding, vnode) /* istanbul ignore next */ {\n    unbindTargets(vnode, binding, listenTypes)\n    // Remove our $root listener\n    if (el[BV_TOGGLE]) {\n      vnode.context.$root.$off(EVENT_STATE, el[BV_TOGGLE])\n      vnode.context.$root.$off(EVENT_STATE_SYNC, el[BV_TOGGLE])\n    }\n    // Reset custom  props\n    resetProp(el, BV_TOGGLE)\n    resetProp(el, BV_TOGGLE_STATE)\n    resetProp(el, BV_TOGGLE_CONTROLS)\n    resetProp(el, BV_TOGGLE_TARGETS)\n    // Reset classes/attrs\n    removeClass(el, 'collapsed')\n    removeAttr(el, 'aria-expanded')\n    removeAttr(el, 'aria-controls')\n    removeAttr(el, 'role')\n  }\n}\n"],"sourceRoot":""}